<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagrama de Sankey de Energ√≠a</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #2c3e50;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        /* Header styles */
        h1 {
            font-size: 2.5rem;
            font-weight: 300;
            color: #34495e;
            margin-bottom: 30px;
            text-align: center;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Controls container */
        .controls-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Label styles */
        label {
            font-size: 1rem;
            font-weight: 500;
            color: #34495e;
            white-space: nowrap;
        }

        /* Select dropdown styles */
        select {
            font-family: inherit;
            font-size: 1rem;
            padding: 10px 15px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            background: white;
            color: #2c3e50;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        select:hover {
            border-color: #3498db;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.2);
        }

        select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        /* Diagram container */
        .diagram-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 95%;
            margin: 0 auto;
        }

        #sankey-diagram {
            width: 100%;
            height: 85vh;
            min-height: 600px;
            border-radius: 12px;
            overflow: hidden;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }

            h1 {
                font-size: 2rem;
                margin-bottom: 20px;
            }

            .controls-container {
                padding: 15px 20px;
                margin-bottom: 20px;
                flex-direction: column;
                gap: 10px;
            }

            .diagram-container {
                width: 98%;
                padding: 15px;
            }

            #sankey-diagram {
                height: 75vh;
                min-height: 500px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.75rem;
            }

            .controls-container {
                padding: 12px 15px;
            }

            .diagram-container {
                width: 100%;
                padding: 12px;
            }

            #sankey-diagram {
                height: 70vh;
                min-height: 450px;
            }

            select {
                font-size: 0.9rem;
                padding: 8px 12px;
                min-width: 100px;
            }
        }

        /* Loading state */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        .loading::after {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid #bdc3c7;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Error state */
        .error {
            background: #fee;
            border: 1px solid #fcc;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }

        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            body {
                background: white;
                color: black;
            }

            .controls-container,
            .diagram-container {
                background: white;
                border: 2px solid black;
            }

            select {
                border: 2px solid black;
            }
        }

        /* Column Labels Controls Styles */
        .column-labels-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .column-labels-controls label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            user-select: none;
        }

        .column-labels-controls input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #3498db;
        }

        /* Column Label Styles */
        .column-label {
            position: absolute;
            z-index: 1000;
            pointer-events: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .column-label-title {
            margin: 0;
            line-height: 1.2;
            font-weight: 600;
        }

        .column-label-description {
            margin: 2px 0 0 0;
            line-height: 1.1;
            opacity: 0.7;
            font-size: 0.8em;
        }

        /* Export Controls Styles */
        .export-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .export-btn {
            font-family: inherit;
            font-size: 0.9rem;
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .config-btn {
            background: #6c757d;
            color: white;
        }

        .config-btn:hover {
            background: #5a6268;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
        }

        .png-btn {
            background: #28a745;
            color: white;
        }

        .png-btn:hover {
            background: #218838;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .svg-btn {
            background: #007bff;
            color: white;
        }

        .svg-btn:hover {
            background: #0056b3;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        }

        .export-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-header {
            padding: 20px 25px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            color: #2c3e50;
            font-weight: 600;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #000;
        }

        .modal-body {
            padding: 25px;
        }

        .config-section {
            margin-bottom: 25px;
        }

        .config-section h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .config-group {
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .config-group label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #495057;
        }

        .config-group input[type="number"],
        .config-group input[type="text"],
        .config-group select {
            padding: 8px 12px;
            border: 2px solid #e1e8ed;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .config-group input[type="number"]:focus,
        .config-group input[type="text"]:focus,
        .config-group select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .config-group input[type="checkbox"] {
            margin-right: 8px;
        }

        .modal-footer {
            padding: 20px 25px;
            border-top: 1px solid #e9ecef;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .btn-primary {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.3s ease;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.3s ease;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        /* Progress Modal Styles */
        .progress-modal {
            max-width: 400px;
            text-align: center;
        }

        .progress-content {
            padding: 30px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e9ecef;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .progress-content h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }

        .progress-content p {
            margin: 0 0 20px 0;
            color: #6c757d;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Responsive adjustments for export controls */
        @media (max-width: 768px) {
            .export-controls {
                width: 100%;
                justify-content: center;
                margin-top: 10px;
            }

            .export-btn {
                font-size: 0.8rem;
                padding: 6px 12px;
            }

            .modal-content {
                width: 95%;
                margin: 10% auto;
            }
        }

        @media (max-width: 480px) {
            .export-controls {
                flex-direction: column;
                gap: 8px;
            }

            .export-btn {
                width: 100%;
                justify-content: center;
            }
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            body {
                background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
                color: #ecf0f1;
            }

            h1 {
                color: #ecf0f1;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            }

            .controls-container,
            .diagram-container {
                background: rgba(44, 62, 80, 0.95);
                border: 1px solid rgba(236, 240, 241, 0.1);
            }

            label {
                color: #ecf0f1;
            }

            select {
                background: #34495e;
                color: #ecf0f1;
                border-color: #4a6741;
            }

            select:hover {
                border-color: #5dade2;
            }

            .error {
                background: #4a2c2a;
                border-color: #8b4513;
                color: #ff6b6b;
            }

            .modal-content {
                background: #34495e;
                color: #ecf0f1;
            }

            .modal-header {
                border-bottom-color: #4a6741;
            }

            .modal-header h3 {
                color: #ecf0f1;
            }

            .modal-footer {
                border-top-color: #4a6741;
            }

            .config-section h4 {
                color: #ecf0f1;
            }

            .config-group label {
                color: #ecf0f1;
            }

            .config-group input[type="number"],
            .config-group input[type="text"],
            .config-group select {
                background: #2c3e50;
                color: #ecf0f1;
                border-color: #4a6741;
            }

            .progress-content h3 {
                color: #ecf0f1;
            }

            .progress-content p {
                color: #bdc3c7;
            }
        }
    </style>
</head>

<body>
    <h1>Diagrama de Sankey de Energ√≠a en M√©xico</h1>
    <div class="controls-container">
        <label for="year-selector">Selecciona un a√±o:</label>
        <select id="year-selector"></select>

        <!-- Column Labels Controls -->
        <div class="column-labels-controls">
            <label>
                <input type="checkbox" id="column-labels-toggle">
                Mostrar etiquetas de columnas
            </label>
            <button id="add-example-labels-btn" class="export-btn config-btn"
                style="font-size: 0.8rem; padding: 6px 12px;">
                + Agregar Ejemplos
            </button>
            <button id="clear-labels-btn" class="export-btn"
                style="background: #dc3545; color: white; font-size: 0.8rem; padding: 6px 12px;">
                üóëÔ∏è Limpiar
            </button>
        </div>

        <!-- Export Controls -->
        <div class="export-controls">
            <button id="export-config-btn" class="export-btn config-btn">‚öôÔ∏è Configurar Exportaci√≥n</button>
            <button id="export-png-btn" class="export-btn png-btn">üì∑ Exportar PNG</button>
            <button id="export-svg-btn" class="export-btn svg-btn">üìÑ Exportar SVG</button>
        </div>
    </div>

    <!-- Export Configuration Modal -->
    <div id="export-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Configuraci√≥n de Exportaci√≥n</h3>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="config-section">
                    <h4>Resoluci√≥n PNG</h4>
                    <div class="config-group">
                        <label for="png-width">Ancho (px):</label>
                        <input type="number" id="png-width" value="1920" min="800" max="4000" step="100">
                    </div>
                    <div class="config-group">
                        <label for="png-height">Alto (px):</label>
                        <input type="number" id="png-height" value="1080" min="600" max="3000" step="100">
                    </div>
                    <div class="config-group">
                        <label for="png-scale">Escala:</label>
                        <select id="png-scale">
                            <option value="1">1x (Normal)</option>
                            <option value="2" selected>2x (Alta calidad)</option>
                            <option value="3">3x (Muy alta calidad)</option>
                        </select>
                    </div>
                </div>

                <div class="config-section">
                    <h4>Opciones Generales</h4>
                    <div class="config-group">
                        <label>
                            <input type="checkbox" id="transparent-bg" checked>
                            Fondo transparente (PNG)
                        </label>
                    </div>
                    <div class="config-group">
                        <label>
                            <input type="checkbox" id="include-column-labels" checked>
                            Incluir etiquetas de columnas en exportaci√≥n
                        </label>
                    </div>
                    <div class="config-group">
                        <label for="filename-prefix">Prefijo del archivo:</label>
                        <input type="text" id="filename-prefix" value="sankey_energia" placeholder="sankey_energia">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="save-config-btn" class="btn-primary">Guardar Configuraci√≥n</button>
                <button id="cancel-config-btn" class="btn-secondary">Cancelar</button>
            </div>
        </div>
    </div>

    <!-- Export Progress Modal -->
    <div id="export-progress-modal" class="modal">
        <div class="modal-content progress-modal">
            <div class="progress-content">
                <div class="spinner"></div>
                <h3 id="progress-title">Exportando...</h3>
                <p id="progress-message">Preparando imagen para descarga</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
            </div>
        </div>
    </div>
    <div class="diagram-container">
        <div id="sankey-diagram"></div>
    </div>

    <!-- Incluir los m√≥dulos -->
    <script src="js/DataManager.js"></script>
    <script src="js/StyleManager.js"></script>
    <script src="js/LayoutEngine.js"></script>
    <script src="js/NodeFactory.js"></script>
    <script src="js/LinkManager.js"></script>
    <script src="js/PopupManager.js"></script>
    <script src="js/ExportManager.js"></script>
    <script src="js/ColumnLabelsManager.js"></script>

    <script>
        const yearSelector = document.getElementById('year-selector');
        const sankeyDiv = document.getElementById('sankey-diagram');
        let dataManager = null;
        let styleManager = null;
        let layoutEngine = null;
        let nodeFactory = null;
        let linkManager = null;
        let popupManager = null;
        let exportManager = null;
        let columnLabelsManager = null;

        // Export Configuration Management
        let exportConfig = {
            png: {
                width: 1920,
                height: 1080,
                scale: 2
            },
            transparentBg: true,
            includeColumnLabels: true,
            filenamePrefix: 'sankey_energia'
        };

        // Cargar los datos desde el archivo JSON y inicializar DataManager
        fetch('datos_energia_completo.json')
            .then(response => response.json())
            .then(data => {
                try {
                    // Inicializar DataManager con los datos cargados
                    dataManager = new DataManager(data);

                    // Inicializar StyleManager
                    styleManager = new StyleManager();

                    // Inicializar LayoutEngine
                    layoutEngine = new LayoutEngine();

                    // Inicializar LinkManager con referencias a otros m√≥dulos
                    linkManager = new LinkManager({
                        dataManager: dataManager,
                        styleManager: styleManager,
                        nodeFactory: null, // Se asignar√° despu√©s
                        popupManager: null // Se asignar√° despu√©s
                    });

                    // Inicializar NodeFactory con referencias a otros m√≥dulos
                    nodeFactory = new NodeFactory({
                        dataManager: dataManager,
                        styleManager: styleManager,
                        layoutEngine: layoutEngine,
                        linkManager: linkManager
                    });

                    // Asignar NodeFactory al LinkManager
                    linkManager.nodeFactory = nodeFactory;

                    // Inicializar PopupManager con referencias a otros m√≥dulos
                    popupManager = new PopupManager({
                        dataManager: dataManager,
                        styleManager: styleManager,
                        nodeFactory: nodeFactory
                    });

                    // Asignar PopupManager al LinkManager
                    linkManager.popupManager = popupManager;

                    // Inicializar ColumnLabelsManager con referencias a otros m√≥dulos
                    columnLabelsManager = new ColumnLabelsManager({
                        enabled: false, // Inicialmente deshabilitado
                        layoutEngine: layoutEngine,
                        styleManager: styleManager
                    });

                    // Aplicar tema por defecto y estilos de popup
                    styleManager.applyTheme();
                    popupManager.applyPopupStyles();

                    // Mostrar estad√≠sticas de los datos cargados
                    const stats = dataManager.getDataStats();
                    console.log('Datos cargados:', stats);
                    console.log('StyleManager inicializado con', Object.keys(styleManager.getAllColors()).length, 'colores');

                    // Mostrar estad√≠sticas del LayoutEngine
                    const layoutStats = layoutEngine.getLayoutStats();
                    console.log('LayoutEngine inicializado con', layoutStats.totalColumns, 'columnas');

                    // Mostrar estad√≠sticas del NodeFactory
                    const nodeFactoryStats = nodeFactory.getNodeStats();
                    console.log('NodeFactory inicializado con', nodeFactory.getRegisteredTypes().length, 'tipos de nodos registrados');

                    populateYearSelector();
                    // Inicializar controles de etiquetas de columnas
                    initializeColumnLabelsControls();
                    // Inicializar el gr√°fico con el primer a√±o disponible
                    updateSankey(yearSelector.value);

                    // Inicializar ExportManager despu√©s de que el diagrama est√© listo
                    setTimeout(() => {
                        try {
                            exportManager = new ExportManager(sankeyDiv, exportConfig, columnLabelsManager);
                            console.log('ExportManager inicializado correctamente con soporte para etiquetas de columnas');
                        } catch (error) {
                            console.error('Error inicializando ExportManager:', error);
                        }
                    }, 1000);
                } catch (error) {
                    console.error('Error al inicializar DataManager:', error);
                    alert('Error al cargar los datos. Por favor, recarga la p√°gina.');
                }
            })
            .catch(error => {
                console.error('Error al cargar el JSON:', error);
                alert('Error al cargar el archivo de datos. Verifica que el archivo existe.');
            });

        // Poblar el selector de a√±os din√°micamente usando DataManager
        function populateYearSelector() {
            if (!dataManager) {
                console.error('DataManager no est√° inicializado');
                return;
            }

            // Usar el m√©todo del DataManager para obtener a√±os disponibles
            const sortedYears = dataManager.getAvailableYears();

            // Limpiar opciones existentes
            yearSelector.innerHTML = '';

            sortedYears.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearSelector.appendChild(option);
            });

            // A√±adir el evento para actualizar el gr√°fico cuando cambia el a√±o
            yearSelector.addEventListener('change', (event) => {
                updateSankey(event.target.value);
            });
        }

        // Initialize export functionality
        function initializeExportControls() {
            const exportConfigBtn = document.getElementById('export-config-btn');
            const exportPngBtn = document.getElementById('export-png-btn');
            const exportSvgBtn = document.getElementById('export-svg-btn');
            const exportModal = document.getElementById('export-modal');
            const exportProgressModal = document.getElementById('export-progress-modal');
            const closeBtn = document.querySelector('.close');
            const saveConfigBtn = document.getElementById('save-config-btn');
            const cancelConfigBtn = document.getElementById('cancel-config-btn');

            // Open configuration modal
            exportConfigBtn.addEventListener('click', () => {
                loadConfigToModal();
                exportModal.style.display = 'block';
            });

            // Close modal events
            closeBtn.addEventListener('click', () => {
                exportModal.style.display = 'none';
            });

            cancelConfigBtn.addEventListener('click', () => {
                exportModal.style.display = 'none';
            });

            // Close modal when clicking outside
            window.addEventListener('click', (event) => {
                if (event.target === exportModal) {
                    exportModal.style.display = 'none';
                }
                if (event.target === exportProgressModal) {
                    exportProgressModal.style.display = 'none';
                }
            });

            // Save configuration
            saveConfigBtn.addEventListener('click', () => {
                saveConfigFromModal();
                exportModal.style.display = 'none';
            });

            // Export PNG
            exportPngBtn.addEventListener('click', () => {
                exportDiagram('png');
            });

            // Export SVG
            exportSvgBtn.addEventListener('click', () => {
                exportDiagram('svg');
            });
        }

        // Load current config to modal
        function loadConfigToModal() {
            document.getElementById('png-width').value = exportConfig.png.width;
            document.getElementById('png-height').value = exportConfig.png.height;
            document.getElementById('png-scale').value = exportConfig.png.scale;
            document.getElementById('transparent-bg').checked = exportConfig.transparentBg;
            document.getElementById('include-column-labels').checked = exportConfig.includeColumnLabels !== false;
            document.getElementById('filename-prefix').value = exportConfig.filenamePrefix;
        }

        // Save config from modal
        function saveConfigFromModal() {
            exportConfig.png.width = parseInt(document.getElementById('png-width').value);
            exportConfig.png.height = parseInt(document.getElementById('png-height').value);
            exportConfig.png.scale = parseInt(document.getElementById('png-scale').value);
            exportConfig.transparentBg = document.getElementById('transparent-bg').checked;
            exportConfig.includeColumnLabels = document.getElementById('include-column-labels').checked;
            exportConfig.filenamePrefix = document.getElementById('filename-prefix').value || 'sankey_energia';

            // Update ExportManager configuration if it's initialized
            if (exportManager) {
                exportManager.updateConfig(exportConfig);
                console.log('ExportManager configuration updated:', exportConfig);
            }
        }

        // Show progress modal
        function showProgressModal(format) {
            const progressModal = document.getElementById('export-progress-modal');
            const progressTitle = document.getElementById('progress-title');
            const progressMessage = document.getElementById('progress-message');
            const progressFill = document.getElementById('progress-fill');

            progressTitle.textContent = `Exportando ${format.toUpperCase()}...`;
            progressMessage.textContent = 'Preparando imagen para descarga';
            progressFill.style.width = '0%';
            progressModal.style.display = 'block';

            return {
                updateProgress: (percent, message) => {
                    progressFill.style.width = `${percent}%`;
                    if (message) progressMessage.textContent = message;
                },
                close: () => {
                    progressModal.style.display = 'none';
                }
            };
        }

        // Export diagram function using ExportManager
        async function exportDiagram(format) {
            if (!exportManager) {
                alert('ExportManager no est√° inicializado. Por favor, espera a que se cargue completamente.');
                return;
            }

            if (!exportManager.isDiagramReady()) {
                alert('El diagrama no est√° listo para exportar. Por favor, espera a que se cargue completamente.');
                return;
            }

            const progress = showProgressModal(format);
            const currentYear = yearSelector.value;

            try {
                // Disable export buttons during export
                setExportButtonsState(false);

                // Update ExportManager configuration
                exportManager.updateConfig(exportConfig);

                // Prepare export options with current year in filename
                const exportOptions = {
                    filename: `${exportConfig.filenamePrefix}_${currentYear}`
                };

                let result;
                if (format === 'png') {
                    // Export PNG using ExportManager
                    result = await exportManager.exportToPNG(exportOptions, (percent, message) => {
                        progress.updateProgress(percent, message);
                    });
                } else if (format === 'svg') {
                    // Export SVG using ExportManager
                    result = await exportManager.exportToSVG(exportOptions, (percent, message) => {
                        progress.updateProgress(percent, message);
                    });
                } else {
                    throw new Error(`Formato no soportado: ${format}`);
                }

                // Show success message
                console.log(`Exportaci√≥n ${format.toUpperCase()} exitosa:`, result);

                // Close progress modal after a short delay
                setTimeout(() => {
                    progress.close();
                }, 1000);

            } catch (error) {
                console.error('Error durante la exportaci√≥n:', error);
                progress.close();

                let errorMessage = 'Error desconocido durante la exportaci√≥n';
                if (error.message) {
                    errorMessage = error.message;
                } else if (typeof error === 'string') {
                    errorMessage = error;
                }

                alert(`Error al exportar ${format.toUpperCase()}: ${errorMessage}`);
            } finally {
                // Re-enable export buttons
                setExportButtonsState(true);
            }
        }

        // Enable/disable export buttons
        function setExportButtonsState(enabled) {
            const exportButtons = document.querySelectorAll('.export-btn');
            exportButtons.forEach(btn => {
                btn.disabled = !enabled;
            });
        }

        // Initialize column labels controls
        function initializeColumnLabelsControls() {
            const columnLabelsToggle = document.getElementById('column-labels-toggle');

            if (!columnLabelsToggle) {
                console.warn('Column labels toggle not found');
                return;
            }

            // Add event listener for toggle
            columnLabelsToggle.addEventListener('change', (event) => {
                const enabled = event.target.checked;

                if (columnLabelsManager) {
                    columnLabelsManager.setEnabled(enabled);
                    console.log(`Etiquetas de columnas ${enabled ? 'habilitadas' : 'deshabilitadas'}`);
                } else {
                    console.warn('ColumnLabelsManager no est√° inicializado');
                }
            });

            // Handle window resize to update label positions
            window.addEventListener('resize', () => {
                if (columnLabelsManager && columnLabelsManager.isEnabled()) {
                    columnLabelsManager.handleResize();
                }
            });

            // Add event listeners for example and clear buttons
            const addExampleBtn = document.getElementById('add-example-labels-btn');
            const clearLabelsBtn = document.getElementById('clear-labels-btn');

            if (addExampleBtn) {
                addExampleBtn.addEventListener('click', addExampleLabels);
            }

            if (clearLabelsBtn) {
                clearLabelsBtn.addEventListener('click', clearAllLabels);
            }

            console.log('Controles de etiquetas de columnas inicializados');
        }

        // Funci√≥n de ejemplo para agregar etiquetas manualmente
        function addExampleLabels() {
            if (!columnLabelsManager) {
                console.warn('ColumnLabelsManager no est√° inicializado');
                return;
            }

            // Ejemplo 1: Etiqueta en la parte superior izquierda
            columnLabelsManager.addLabel('oferta', {
                title: 'Oferta',
                description: 'Fuentes de energ√≠a',
                x: 0.1,  // 10% desde la izquierda
                y: 0.05, // 5% desde arriba
                visible: true
            });

            // Ejemplo 2: Etiqueta en el centro superior
            columnLabelsManager.addLabel('transformacion', {
                title: 'Transformaci√≥n',
                description: 'Procesos de conversi√≥n',
                x: 0.5,  // 50% desde la izquierda (centro)
                y: 0.05, // 5% desde arriba
                visible: true
            });

            // Ejemplo 3: Etiqueta en la parte superior derecha
            columnLabelsManager.addLabel('consumo', {
                title: 'Consumo',
                description: 'Destino final',
                x: 0.9,  // 90% desde la izquierda
                y: 0.05, // 5% desde arriba
                visible: true
            });

            // Ejemplo 4: Etiqueta con estilo personalizado
            columnLabelsManager.addLabel('hub-central', {
                title: 'Hub Central',
                description: 'Concentraci√≥n',
                x: 0.3,  // 30% desde la izquierda
                y: 0.1,  // 10% desde arriba
                visible: true,
                customStyle: {
                    backgroundColor: 'rgba(52, 152, 219, 0.9)',
                    color: 'white',
                    fontSize: 16
                }
            });

            console.log('Etiquetas de ejemplo agregadas');
        }

        // Funci√≥n para limpiar todas las etiquetas
        function clearAllLabels() {
            if (columnLabelsManager) {
                columnLabelsManager.clearAllLabels();
                console.log('Todas las etiquetas removidas');
            }
        }

        // Initialize export controls when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializeExportControls();
        });

        // Funci√≥n para actualizar el diagrama de Sankey (Etapa 1.7: A√±adir Salidas Completas)
        function updateSankey(year) {
            console.log(`Actualizando gr√°fico para el a√±o: ${year}`);

            Plotly.purge(sankeyDiv);

            const labels = [];
            const nodeColors = [];
            const nodeMap = new Map();
            const nodeX = []; // Inicializar arrays de posiciones
            const nodeY = []; // Inicializar arrays de posiciones
            const nodeCustomdata = []; // Nuevo array para el customdata de cada nodo

            // --- ARRAYS PARA LOS ENLACES DEL DIAGRAMA SANKEY ---
            const source = [];
            const target = [];
            const value = [];
            const linkColors = [];
            const linkCustomdata = [];

            function addNode(name, color, nodeType = 'default') {
                if (nodeMap.has(name)) {
                    return nodeMap.get(name);
                }
                let finalColor = color;
                if (styleManager) {
                    finalColor = styleManager.getEnergyColor(name, nodeType) || color;
                }

                const nodeIndex = labels.length;
                nodeMap.set(name, nodeIndex);
                labels.push(name);
                nodeColors.push(finalColor);
                nodeCustomdata.push(''); // Inicializar con placeholder, se llenar√° despu√©s
                return nodeIndex;
            }

            // --- AQU√ç EMPEZAREMOS A CREAR Y POSICIONAR LOS NODOS ---
            const importacionNodeData = dataManager.getNodeData('Importaci√≥n');
            if (importacionNodeData) {
                const importacionIndex = addNode(importacionNodeData['Nodo Padre'], importacionNodeData.color);
                nodeX[importacionIndex] = 0.05;
                nodeY[importacionIndex] = 0.05; // Ahora el m√°s arriba
                // Generar customdata espec√≠fico para Importaci√≥n
                const importacionBreakdownForPopup = popupManager.calculateNodeBreakdown(importacionNodeData, year, 'Energ√≠a Primaria');
                console.log(`[DEBUG - Importaci√≥n] Breakdown (Primaria) para ${year}:`, importacionBreakdownForPopup);
                nodeCustomdata[importacionIndex] = popupManager.generateNodePopup(
                    importacionNodeData['Nodo Padre'],
                    importacionNodeData, // Pasar todos los datos del nodo padre para la descripci√≥n
                    year,
                    importacionBreakdownForPopup, // Pasar el breakdown calculado como additionalData
                    'text',
                    'Energ√≠a Primaria'
                );
            } else {
                console.error("Error: Datos para 'Importaci√≥n' no encontrados en DataManager.");
            }

            const produccionNodeData = dataManager.getNodeData('Producci√≥n');
            if (produccionNodeData) {
                const produccionIndex = addNode(produccionNodeData['Nodo Padre'], produccionNodeData.color);
                nodeX[produccionIndex] = 0.05;
                nodeY[produccionIndex] = 0.4; // Ahora el m√°s abajo
                // Generar customdata espec√≠fico para Producci√≥n
                const produccionBreakdownForPopup = popupManager.calculateNodeBreakdown(produccionNodeData, year, 'Energ√≠a Primaria');
                console.log(`[DEBUG - Producci√≥n] Breakdown (Primaria) para ${year}:`, produccionBreakdownForPopup);
                nodeCustomdata[produccionIndex] = popupManager.generateNodePopup(
                    produccionNodeData['Nodo Padre'],
                    produccionNodeData,
                    year,
                    produccionBreakdownForPopup,
                    'text',
                    'Energ√≠a Primaria'
                );
            } else {
                console.error("Error: Datos para 'Producci√≥n' no encontrados en DataManager.");
            }

            // Agregar Variaci√≥n de Inventarios
            const variacionNodeData = dataManager.getNodeData('Variaci√≥n de Inventarios');
            if (variacionNodeData) {
                const variacionIndex = addNode(variacionNodeData['Nodo Padre'], variacionNodeData.color);
                nodeX[variacionIndex] = 0.05;
                nodeY[variacionIndex] = 0.2; // Ahora en el medio

                // Calcular el desglose completo para la variaci√≥n de inventarios para el popup
                const variacionBreakdownForPopup = popupManager.calculateNodeBreakdown(variacionNodeData, year, 'Energ√≠a Primaria');
                console.log(`[DEBUG - Variaci√≥n de Inventarios] Breakdown Total (Primaria) para ${year}:`, variacionBreakdownForPopup.total);

                let variacionPopupData = {};

                // Preparar los campos de incremento/decremento para el popup
                // Usar input_total para la variaci√≥n positiva y output_total para la negativa
                if (variacionBreakdownForPopup.input_total > 0) {
                    variacionPopupData.variacion_positiva = variacionBreakdownForPopup.input_total;
                }
                if (variacionBreakdownForPopup.output_total > 0) {
                    variacionPopupData.variacion_negativa = variacionBreakdownForPopup.output_total;
                }
                // No pasar el valor total neto, ya que se mostrar√°n los componentes separados
                // variacionPopupData.total = variacionBreakdownForPopup.total;
                console.log(`[DEBUG - Variaci√≥n de Inventarios] Datos para popup:`, variacionPopupData);

                // Generar customdata espec√≠fico para Variaci√≥n de Inventarios
                nodeCustomdata[variacionIndex] = popupManager.generateNodePopup(
                    variacionNodeData['Nodo Padre'],
                    variacionNodeData,
                    year,
                    variacionPopupData, // Pasar los datos de variaci√≥n espec√≠ficos
                    'text',
                    'Energ√≠a Primaria'
                );
            } else {
                console.error("Error: Datos para 'Variaci√≥n de Inventarios' no encontrados en DataManager.");
            }

            // --- Nodos de Energ√©ticos Primarios de Oferta Interna Bruta ---
            const ofertaInternaBrutaFullData = dataManager.getNodeData('Oferta Interna Bruta');
            const energeticNodesMap = new Map(); // Para almacenar los √≠ndices de los nuevos nodos de energ√©ticos

            if (ofertaInternaBrutaFullData && ofertaInternaBrutaFullData['Nodos Hijo']) {
                const primaryEnergetics = ofertaInternaBrutaFullData['Nodos Hijo'].filter(child => child.tipo === 'Energ√≠a Primaria');

                // Calcular posiciones Y para distribuir los nodos de energ√©ticos
                const startY = 0.1; // Posici√≥n inicial
                const endY = 0.9;   // Posici√≥n final
                const stepY = (endY - startY) / (primaryEnergetics.length - 1 || 1); // Paso entre nodos

                primaryEnergetics.forEach((energetic, index) => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticColor = styleManager.getEnergyColor(energeticName) || energetic.color; // Obtener color del StyleManager o del dato

                    const energeticIndex = addNode(energeticName, energeticColor);
                    energeticNodesMap.set(energeticName, energeticIndex); // Guardar el √≠ndice

                    nodeX[energeticIndex] = 0.2; // Columna de Oferta Interna Bruta
                    nodeY[energeticIndex] = startY + (index * stepY); // Distribuir verticalmente

                    // Generar customdata sencillo para cada energ√©tico
                    const energeticValue = dataManager.getEnergeticValue('Oferta Interna Bruta', energeticName, year);
                    let energeticPopupData = {};
                    if (energeticValue !== null) {
                        energeticPopupData.total = energeticValue; // Usar 'total' para el simple_source template
                    }

                    nodeCustomdata[energeticIndex] = popupManager.generateNodePopup(
                        energeticName,
                        {},
                        year,
                        energeticPopupData,
                        'text',
                        'Energ√≠a Primaria',
                        'simple_source'
                    );
                });
            } else {
                console.error("Error: Datos de 'Oferta Interna Bruta' o sus hijos no encontrados para crear energ√©ticos primarios.");
            }

            // --- Nodo de Exportaci√≥n ---
            const exportacionNodeData = dataManager.getNodeData('Exportaci√≥n');
            console.log(`[DEBUG] Datos de Exportaci√≥n:`, exportacionNodeData);
            if (exportacionNodeData) {
                const exportacionIndex = addNode(exportacionNodeData['Nodo Padre'], exportacionNodeData.color);
                nodeX[exportacionIndex] = 0.3; // Posici√≥n horizontal
                nodeY[exportacionIndex] = 0.99; // Posici√≥n vertical;

                // Calcular el desglose para el popup de Exportaci√≥n (solo energ√©ticos primarios)
                const exportacionBreakdownForPopup = popupManager.calculateNodeBreakdown(exportacionNodeData, year, 'Energ√≠a Primaria');
                console.log(`[DEBUG - Exportaci√≥n] Breakdown (Primaria) para ${year}:`, exportacionBreakdownForPopup);

                nodeCustomdata[exportacionIndex] = popupManager.generateNodePopup(
                    exportacionNodeData['Nodo Padre'],
                    exportacionNodeData,
                    year,
                    exportacionBreakdownForPopup,
                    'text',
                    'Energ√≠a Primaria'
                );
            } else {
                console.error("Error: Datos para 'Exportaci√≥n' no encontrados en DataManager.");
            }

            // --- Nodo de Energ√≠a No Aprovechada ---
            const energiaNoAprovechadaNodeData = dataManager.getNodeData('Energ√≠a No Aprovechada');
            console.log(`[DEBUG] Datos de Energ√≠a No Aprovechada:`, energiaNoAprovechadaNodeData);
            if (energiaNoAprovechadaNodeData) {
                const energiaNoAprovechadaIndex = addNode(energiaNoAprovechadaNodeData['Nodo Padre'], energiaNoAprovechadaNodeData.color);
                nodeX[energiaNoAprovechadaIndex] = 0.35; // Posici√≥n horizontal
                nodeY[energiaNoAprovechadaIndex] = 0.9; // Posici√≥n vertical;

                // Calcular el desglose para el popup de Energ√≠a No Aprovechada (solo energ√©ticos primarios)
                const energiaNoAprovechadaBreakdownForPopup = popupManager.calculateNodeBreakdown(energiaNoAprovechadaNodeData, year, 'Energ√≠a Primaria');
                console.log(`[DEBUG - Energ√≠a No Aprovechada] Breakdown (Primaria) para ${year}:`, energiaNoAprovechadaBreakdownForPopup);

                nodeCustomdata[energiaNoAprovechadaIndex] = popupManager.generateNodePopup(
                    energiaNoAprovechadaNodeData['Nodo Padre'],
                    energiaNoAprovechadaNodeData,
                    year,
                    energiaNoAprovechadaBreakdownForPopup,
                    'text',
                    'Energ√≠a Primaria'
                );
            } else {
                console.error("Error: Datos para 'Energ√≠a No Aprovechada' no encontrados en DataManager.");
            }

            // --- Nodo de Coquizadoras y Hornos ---
            const coquizadorasyhornosNodeData = dataManager.getNodeData('Coquizadoras y Hornos');
            console.log(`[DEBUG] Datos de Coquizadoras y Hornos:`, coquizadorasyhornosNodeData);
            if (coquizadorasyhornosNodeData) {
                const coquizadorasyhornosIndex = addNode(coquizadorasyhornosNodeData['Nodo Padre'], coquizadorasyhornosNodeData.color);
                nodeX[coquizadorasyhornosIndex] = 0.35; // Posici√≥n horizontal
                nodeY[coquizadorasyhornosIndex] = 0.1; // Posici√≥n vertical;

                // Calcular el desglose para el popup de Coquizadoras y Hornos (solo energ√©ticos primarios)
                const coquizadorasyhornosBreakdownForPopup = popupManager.calculateNodeBreakdown(coquizadorasyhornosNodeData, year, 'Energ√≠a Primaria');
                console.log(`[DEBUG - Coquizadoras y Hornos] Breakdown (Primaria) para ${year}:`, coquizadorasyhornosBreakdownForPopup);

                nodeCustomdata[coquizadorasyhornosIndex] = popupManager.generateNodePopup(
                    coquizadorasyhornosNodeData['Nodo Padre'],
                    coquizadorasyhornosNodeData,
                    year,
                    coquizadorasyhornosBreakdownForPopup,
                    'text',
                    'Energ√≠a Primaria',
                    'simple_source'
                );
            } else {
                console.error("Error: Datos para 'Coquizadoras y Hornos' no encontrados en DataManager.");
            }

            // --- Nodo de Plantas de Gas y Fraccionadoras ---
            const plantasdegasyfraccionadorasNodeData = dataManager.getNodeData('Plantas de Gas y Fraccionadoras');
            console.log(`[DEBUG] Datos de Plantas de Gas y Fraccionadoras:`, plantasdegasyfraccionadorasNodeData);
            if (plantasdegasyfraccionadorasNodeData) {
                const plantasdegasyfraccionadorasIndex = addNode(plantasdegasyfraccionadorasNodeData['Nodo Padre'], plantasdegasyfraccionadorasNodeData.color);
                nodeX[plantasdegasyfraccionadorasIndex] = 0.35; // Posici√≥n horizontal
                nodeY[plantasdegasyfraccionadorasIndex] = 0.25; // Posici√≥n vertical;

                // Calcular el desglose para el popup de Plantas de Gas y Fraccionadoras (solo energ√©ticos primarios)
                const plantasdegasyfraccionadorasBreakdownForPopup = popupManager.calculateNodeBreakdown(plantasdegasyfraccionadorasNodeData, year, 'Energ√≠a Primaria');
                console.log(`[DEBUG - Plantas de Gas y Fraccionadoras] Breakdown (Primaria) para ${year}:`, plantasdegasyfraccionadorasBreakdownForPopup);

                nodeCustomdata[plantasdegasyfraccionadorasIndex] = popupManager.generateNodePopup(
                    plantasdegasyfraccionadorasNodeData['Nodo Padre'],
                    plantasdegasyfraccionadorasNodeData,
                    year,
                    plantasdegasyfraccionadorasBreakdownForPopup,
                    'text',
                    'Energ√≠a Primaria',
                    'simple_source'
                );
            } else {
                console.error("Error: Datos para 'Plantas de Gas y Fraccionadoras' no encontrados en DataManager.");
            }

            // --- Nodo de Refiner√°s y Despuntadoras ---
            const refinerasydespuntadorasNodeData = dataManager.getNodeData('Refiner√≠as y Despuntadoras');
            console.log(`[DEBUG] Datos de Refiner√≠as y Despuntadoras:`, refinerasydespuntadorasNodeData);
            if (refinerasydespuntadorasNodeData) {
                const refinerasydespuntadorasIndex = addNode(refinerasydespuntadorasNodeData['Nodo Padre'], refinerasydespuntadorasNodeData.color);
                nodeX[refinerasydespuntadorasIndex] = 0.35; // Posici√≥n horizontal
                nodeY[refinerasydespuntadorasIndex] = 0.7; // Posici√≥n vertical;

                // Calcular el desglose para el popup de Refiner√≠as y Despuntadoras (solo energ√©ticos primarios)
                const refinerasydespuntadorasBreakdownForPopup = popupManager.calculateNodeBreakdown(refinerasydespuntadorasNodeData, year, 'Energ√≠a Primaria');
                console.log(`[DEBUG - Refiner√≠as y Despuntadoras] Breakdown (Primaria) para ${year}:`, refinerasydespuntadorasBreakdownForPopup);

                nodeCustomdata[refinerasydespuntadorasIndex] = popupManager.generateNodePopup(
                    refinerasydespuntadorasNodeData['Nodo Padre'],
                    refinerasydespuntadorasNodeData,
                    year,
                    refinerasydespuntadorasBreakdownForPopup,
                    'text',
                    'Energ√≠a Primaria',
                    'simple_source'
                );
            } else {
                console.error("Error: Datos para 'Refiner√≠as y Despuntadoras' no encontrados en DataManager.");
            }

            // --- Nodo de Centrales El√©ctricas ---
            const centraleselectricasNodeData = dataManager.getNodeData('Centrales El√©ctricas');
            console.log(`[DEBUG] Datos de Centrales El√©ctricas:`, centraleselectricasNodeData);
            if (centraleselectricasNodeData) {
                const centraleselectricasIndex = addNode(centraleselectricasNodeData['Nodo Padre'], centraleselectricasNodeData.color);
                nodeX[centraleselectricasIndex] = 0.45; // Posici√≥n horizontal
                nodeY[centraleselectricasIndex] = 0.45; // Posici√≥n vertical;

                // Calcular el desglose para el popup de Centrales El√©ctricas
                const centraleselectricasBreakdownForPopup = popupManager.calculateNodeBreakdown(centraleselectricasNodeData, year, 'Energ√≠a Secundaria');
                console.log(`[DEBUG - Centrales El√©ctricas] Breakdown (Energ√≠a El√©ctrica) para ${year}:`, centraleselectricasBreakdownForPopup);

                // Buscar la entrada de Energ√≠a el√©ctrica (notar la tilde en "el√©ctrica")
                const electricidadEntry = centraleselectricasBreakdownForPopup?.children
                    ?.find(child => child.name === 'Energ√≠a el√©ctrica' && child.isInput);

                // Si no la encontramos, mostramos un mensaje de error
                if (!electricidadEntry) {
                    console.error('No se encontr√≥ la entrada de Energ√≠a el√©ctrica en el breakdown');
                    console.log('Entradas disponibles:', centraleselectricasBreakdownForPopup.children?.map(c => c.name));
                }

                // Usamos el valor de la entrada o 0 si no se encuentra
                const energiaElectricaGenerada = electricidadEntry?.value || 0;

                // Crear un objeto con el total de energ√≠a el√©ctrica generada
                const electricidadData = {
                    total: Math.abs(energiaElectricaGenerada), // Tomamos el valor absoluto ya que es generaci√≥n
                    unit: 'PJ'
                };

                nodeCustomdata[centraleselectricasIndex] = popupManager.generateNodePopup(
                    centraleselectricasNodeData['Nodo Padre'],
                    centraleselectricasNodeData,
                    year,
                    electricidadData,
                    'text',
                    null,
                    'simple_source'
                );
            } else {
                console.error("Error: Datos para 'Centrales El√©ctricas' no encontrados en DataManager.");
            }


            // --- Nodos de Energ√©ticos Secundarios de Oferta Interna Bruta ---
            const primaryEnergeticNodesMap = new Map();  // Mapa para los nodos de energ√©ticos primarios
            // 1. Agregar nodos de energ√≠a primaria
            // const primaryEnergetics = ofertaInternaBrutaFullData['Nodos Hijo']
            //     .filter(child => child.tipo === 'Energ√≠a Primaria' && child[year] > 0);
            const secondaryEnergeticNodesMap = new Map(); // Mapa para los nodos de energ√©ticos secundarios
            console.log('Datos de Oferta Interna Bruta:', ofertaInternaBrutaFullData);

            if (ofertaInternaBrutaFullData && ofertaInternaBrutaFullData['Nodos Hijo']) {
                // Filtrar solo los energ√©ticos secundarios
                const secondaryEnergetics = ofertaInternaBrutaFullData['Nodos Hijo']
                    .filter(child => child.tipo === 'Energ√≠a Secundaria');

                console.log('Energ√©ticos secundarios encontrados:',
                    secondaryEnergetics.map(e => e['Nodo Hijo']));

                // Calcular posiciones Y para distribuir los nodos de energ√©ticos
                const startY = 0.1; // Posici√≥n inicial
                const endY = 0.9;   // Posici√≥n final
                const stepY = secondaryEnergetics.length > 1 ?
                    (endY - startY) / (secondaryEnergetics.length - 1) : 0.5; // Evitar divisi√≥n por cero

                secondaryEnergetics.forEach((energetic, index) => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticColor = styleManager.getEnergyColor(energeticName) || energetic.color || '#CCCCCC';

                    console.log(`Creando nodo para ${energeticName} con color:`, energeticColor);

                    const energeticIndex = addNode(energeticName, energeticColor);
                    secondaryEnergeticNodesMap.set(energeticName, energeticIndex);

                    nodeX[energeticIndex] = 0.65; // Posici√≥n X a la derecha
                    nodeY[energeticIndex] = startY + (index * stepY);

                    // Obtener el valor del energ√©tico
                    const energeticValue = dataManager.getEnergeticValue('Oferta Interna Bruta', energeticName, year);
                    let energeticPopupData = {};
                    if (energeticValue !== null) {
                        energeticPopupData.total = Math.abs(energeticValue);
                        energeticPopupData.unit = 'PJ';
                    }

                    console.log(`Nodo creado: ${energeticName} - √çndice: ${energeticIndex}, ` +
                        `X: ${nodeX[energeticIndex]}, Y: ${nodeY[energeticIndex]}`);

                    nodeCustomdata[energeticIndex] = popupManager.generateNodePopup(
                        energeticName,
                        energetic,
                        year,
                        energeticPopupData,
                        'text',
                        'Energ√≠a Secundaria',
                        'simple_source'
                    );
                });

                console.log('Mapa de nodos secundarios:', [...secondaryEnergeticNodesMap.entries()]);
            } else {
                console.error("Error: Datos de 'Oferta Interna Bruta' o sus hijos no encontrados para crear energ√©ticos secundarios.");
            }

            // --- NODO DE IMPORTACI√ìN DE ENERG√âTICOS SECUNDARIOS ---
            if (importacionNodeData && importacionNodeData['Nodos Hijo']) {
                // Filtrar solo los energ√©ticos secundarios
                const secundariosImportados = importacionNodeData['Nodos Hijo']
                    .filter(hijo => hijo.tipo === 'Energ√≠a Secundaria' &&
                        hijo[year] !== undefined &&
                        hijo[year] !== null &&
                        hijo[year] > 0);

                if (secundariosImportados.length > 0) {
                    // Crear nodo de importaci√≥n secundaria
                    const importacionSecundariaIndex = addNode('Importaci√≥n (Secundaria)', importacionNodeData.color);
                    nodeX[importacionSecundariaIndex] = 0.5;
                    nodeY[importacionSecundariaIndex] = 0.05;

                    // Crear customdata para el nodo
                    const importacionSecundariaData = {
                        ...importacionNodeData,
                        'Nodos Hijo': secundariosImportados
                    };

                    const importacionSecundariaBreakdown = popupManager.calculateNodeBreakdown(
                        importacionSecundariaData,
                        year,
                        'Energ√≠a Secundaria'
                    );

                    nodeCustomdata[importacionSecundariaIndex] = popupManager.generateNodePopup(
                        'Importaci√≥n (Secundaria)',
                        importacionSecundariaData,
                        year,
                        importacionSecundariaBreakdown,
                        'text',
                        'Energ√≠a Secundaria',
                        'simple_source'  // Usamos la plantilla simple
                    );

                    // Crear enlaces a los energ√©ticos secundarios
                    secundariosImportados.forEach(energetic => {
                        const energeticName = energetic['Nodo Hijo'];
                        const targetNodeIndex = secondaryEnergeticNodesMap.get(energeticName);

                        if (targetNodeIndex !== undefined) {
                            const energeticValue = parseFloat(energetic[year]) || 0;

                            if (energeticValue > 0) {
                                const linkColor = styleManager.getEnergyColor(energeticName) || '#999999';

                                source.push(importacionSecundariaIndex);
                                target.push(targetNodeIndex);
                                value.push(Math.log10(energeticValue + 1));
                                linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                                linkCustomdata.push(popupManager.generateLinkPopup(
                                    energeticName,
                                    energeticValue,
                                    'Importaci√≥n (Secundaria)',
                                    energeticName,
                                    linkColor,
                                    year,
                                    { flowType: 'import_secondary' }
                                ));
                            }
                        }
                    });
                }
            }

            // --- NODO DE VARIACI√ìN DE INVENTARIOS DE ENERG√âTICOS SECUNDARIOS ---
            if (variacionNodeData && variacionNodeData['Nodos Hijo']) {
                // Filtrar solo los energ√©ticos secundarios
                const secundariosVariacion = variacionNodeData['Nodos Hijo']
                    .filter(hijo => hijo.tipo === 'Energ√≠a Secundaria' &&
                        hijo[year] !== undefined &&
                        hijo[year] !== null &&
                        Math.abs(hijo[year]) > 0);

                if (secundariosVariacion.length > 0) {
                    // Crear nodo de variaci√≥n de inventarios secundarios
                    const variacionSecundariaIndex = addNode('Variaci√≥n de Inventarios ES', variacionNodeData.color);
                    nodeX[variacionSecundariaIndex] = 0.45;
                    nodeY[variacionSecundariaIndex] = 0.15;

                    // Crear customdata para el nodo
                    const variacionSecundariaData = {
                        ...variacionNodeData,
                        'Nodo Padre': 'Variaci√≥n de Inventarios ES', // Asegurar que use el nombre correcto
                        'Nodos Hijo': secundariosVariacion
                    };

                    // Calcular el desglose para el popup
                    const variacionSecundariaBreakdown = popupManager.calculateNodeBreakdown(
                        variacionSecundariaData,
                        year,
                        'Energ√≠a Secundaria'
                    );

                    // Preparar datos para el popup - igual que en el caso primario
                    let variacionSecundariaPopupData = {};
                    if (variacionSecundariaBreakdown.input_total > 0) {
                        variacionSecundariaPopupData.variacion_positiva = variacionSecundariaBreakdown.input_total;
                    }
                    if (variacionSecundariaBreakdown.output_total > 0) {
                        variacionSecundariaPopupData.variacion_negativa = variacionSecundariaBreakdown.output_total;
                    }

                    console.log(`[DEBUG - Variaci√≥n de Inventarios (Secundaria)] Datos para popup:`, variacionSecundariaPopupData);

                    // Generar el popup con los datos espec√≠ficos
                    nodeCustomdata[variacionSecundariaIndex] = popupManager.generateNodePopup(
                        'Variaci√≥n de Inventarios ES',
                        variacionSecundariaData,
                        year,
                        variacionSecundariaPopupData, // Pasamos los datos espec√≠ficos de variaci√≥n
                        'text',
                        'Energ√≠a Secundaria'
                    );

                    // Resto del c√≥digo de creaci√≥n de enlaces se mantiene igual...
                    secundariosVariacion.forEach(energetic => {
                        const energeticName = energetic['Nodo Hijo'];
                        const targetNodeIndex = secondaryEnergeticNodesMap.get(energeticName);
                        const energeticValue = parseFloat(energetic[year]) || 0;

                        if (targetNodeIndex !== undefined && energeticValue !== 0) {
                            const linkColor = styleManager.getEnergyColor(energeticName) || '#999999';
                            const absValue = Math.abs(energeticValue);

                            if (energeticValue > 0) {
                                source.push(variacionSecundariaIndex);
                                target.push(targetNodeIndex);
                                value.push(Math.log10(absValue + 1));
                                linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                                linkCustomdata.push(popupManager.generateLinkPopup(
                                    energeticName,
                                    absValue,
                                    'Variaci√≥n de Inventarios ES',
                                    energeticName,
                                    linkColor,
                                    year,
                                    { flowType: 'inventory_change_secondary' }
                                ));
                            }
                            else if (energeticValue < 0) {
                                source.push(targetNodeIndex);
                                target.push(variacionSecundariaIndex);
                                value.push(Math.log10(absValue + 1));
                                linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                                linkCustomdata.push(popupManager.generateLinkPopup(
                                    energeticName,
                                    absValue,
                                    energeticName,
                                    'Variaci√≥n de Inventarios ES',
                                    linkColor,
                                    year,
                                    { flowType: 'inventory_change_secondary' }
                                ));
                            }
                        }
                    });
                }
            }
            // --- NODO DE EXPORTACI√ìN DE ENERG√âTICOS SECUNDARIOS ---
            if (exportacionNodeData && exportacionNodeData['Nodos Hijo']) {
                // Filtrar solo los energ√©ticos secundarios (valores negativos)
                const secundariosExportacion = exportacionNodeData['Nodos Hijo']
                    .filter(hijo => hijo.tipo === 'Energ√≠a Secundaria' &&
                        hijo[year] !== undefined &&
                        hijo[year] !== null &&
                        hijo[year] < 0);  // Cambiado a < 0 para capturar valores negativos

                if (secundariosExportacion.length > 0) {
                    // Crear nodo de exportaci√≥n secundaria
                    const exportacionSecundariaIndex = addNode('Exportaci√≥n (Secundaria)', exportacionNodeData.color);
                    nodeX[exportacionSecundariaIndex] = 0.8;
                    nodeY[exportacionSecundariaIndex] = 0.95;

                    // Crear customdata para el nodo
                    const exportacionSecundariaData = {
                        ...exportacionNodeData,
                        'Nodos Hijo': secundariosExportacion
                    };

                    // Calcular el desglose para el popup
                    const exportacionSecundariaBreakdown = popupManager.calculateNodeBreakdown(
                        exportacionSecundariaData,
                        year,
                        'Energ√≠a Secundaria'
                    );

                    // Generar el popup
                    nodeCustomdata[exportacionSecundariaIndex] = popupManager.generateNodePopup(
                        'Exportaci√≥n (Secundaria)',
                        exportacionSecundariaData,
                        year,
                        exportacionSecundariaBreakdown,
                        'text',
                        'Energ√≠a Secundaria',
                        'simple_source'  // Usamos la plantilla simple
                    );

                    // Crear enlaces desde los energ√©ticos secundarios a la exportaci√≥n
                    secundariosExportacion.forEach(energetic => {
                        const energeticName = energetic['Nodo Hijo'];
                        const sourceNodeIndex = secondaryEnergeticNodesMap.get(energeticName);
                        const energeticValue = Math.abs(parseFloat(energetic[year]) || 0);  // Tomar valor absoluto

                        if (sourceNodeIndex !== undefined && energeticValue > 0) {
                            const linkColor = styleManager.getEnergyColor(energeticName) || '#999999';

                            // La direcci√≥n es desde el energ√©tico hacia la exportaci√≥n
                            source.push(sourceNodeIndex);
                            target.push(exportacionSecundariaIndex);
                            value.push(Math.log10(energeticValue + 1));
                            linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                            linkCustomdata.push(popupManager.generateLinkPopup(
                                energeticName,
                                energeticValue,  // Usamos el valor absoluto
                                energeticName,
                                'Exportaci√≥n (Secundaria)',
                                linkColor,
                                year,
                                { flowType: 'export_secondary' }
                            ));
                        }
                    });
                }
            }

            // --- NODO DE ENERG√çA NO APROVECHADA DE ENERG√âTICOS SECUNDARIOS ---
            if (energiaNoAprovechadaNodeData && energiaNoAprovechadaNodeData['Nodos Hijo']) {
                // Filtrar solo los energ√©ticos secundarios
                const secundariosNoAprovechados = energiaNoAprovechadaNodeData['Nodos Hijo']
                    .filter(hijo => hijo.tipo === 'Energ√≠a Secundaria' &&
                        hijo[year] !== undefined &&
                        hijo[year] !== null &&
                        hijo[year] > 0);

                if (secundariosNoAprovechados.length > 0) {
                    // Crear nodo de energ√≠a no aprovechada secundaria
                    const noAprovechadaSecundariaIndex = addNode('Energ√≠a No Aprovechada (Secundaria)', energiaNoAprovechadaNodeData.color);
                    nodeX[noAprovechadaSecundariaIndex] = 0.6; // Posici√≥n X intermedia
                    nodeY[noAprovechadaSecundariaIndex] = 0.9; // Misma altura que el nodo primario

                    // Crear customdata para el nodo
                    const noAprovechadaSecundariaData = {
                        ...energiaNoAprovechadaNodeData,
                        'Nodo Padre': 'Energ√≠a No Aprovechada (Secundaria)',
                        'Nodos Hijo': secundariosNoAprovechados
                    };

                    // Calcular el desglose para el popup
                    const noAprovechadaSecundariaBreakdown = popupManager.calculateNodeBreakdown(
                        noAprovechadaSecundariaData,
                        year,
                        'Energ√≠a Secundaria'
                    );

                    // Generar el popup
                    nodeCustomdata[noAprovechadaSecundariaIndex] = popupManager.generateNodePopup(
                        'Energ√≠a No Aprovechada (Secundaria)',
                        noAprovechadaSecundariaData,
                        year,
                        noAprovechadaSecundariaBreakdown,
                        'text',
                        'Energ√≠a Secundaria',
                        'simple_source'  // Usamos la plantilla simple
                    );

                    // Crear enlaces desde los energ√©ticos secundarios a la energ√≠a no aprovechada
                    secundariosNoAprovechados.forEach(energetic => {
                        const energeticName = energetic['Nodo Hijo'];
                        const sourceNodeIndex = secondaryEnergeticNodesMap.get(energeticName);
                        const energeticValue = parseFloat(energetic[year]) || 0;

                        if (sourceNodeIndex !== undefined && energeticValue > 0) {
                            const linkColor = styleManager.getEnergyColor(energeticName) || '#999999';

                            // La direcci√≥n es desde el energ√©tico hacia la energ√≠a no aprovechada
                            source.push(sourceNodeIndex);
                            target.push(noAprovechadaSecundariaIndex);
                            value.push(Math.log10(energeticValue + 1));
                            linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                            linkCustomdata.push(popupManager.generateLinkPopup(
                                energeticName,
                                energeticValue,
                                energeticName,
                                'Energ√≠a No Aprovechada (Secundaria)',
                                linkColor,
                                year,
                                {
                                    flowType: 'unused_energy_secondary',
                                    template: 'simple'  // Usamos la plantilla simple para los enlaces
                                }
                            ));
                        }
                    });
                }
            }


            //CONSUMOS POR SECTORES

            // --- NODO INDUSTRIAL ---
            const industrialNodeData = dataManager.getNodeData('Industrial');
            if (industrialNodeData && industrialNodeData['Nodos Hijo']) {
                // Crear nodo Industrial
                const industrialIndex = addNode(industrialNodeData['Nodo Padre'], industrialNodeData.color);
                nodeX[industrialIndex] = 0.9;
                nodeY[industrialIndex] = 0.15;

                // Calcular el total sumando los valores de los hijos
                const totalIndustrial = industrialNodeData['Nodos Hijo'].reduce((sum, hijo) => {
                    return sum + (parseFloat(hijo[year]) || 0);
                }, 0);

                // Crear un objeto con el formato esperado por la plantilla simple_source
                const popupData = {
                    label: 'Sector Industrial',  // Cambiamos esto
                    total: totalIndustrial,
                    unit: 'PJ' // Ajusta la unidad seg√∫n corresponda
                };

                // Generar el popup
                nodeCustomdata[industrialIndex] = popupManager.generateNodePopup(
                    'Sector Industrial',  // Y aqu√≠ tambi√©n
                    popupData,  // Pasamos los datos formateados
                    year,
                    popupData,  // Mismos datos para el desglose
                    'text',
                    'Todos',
                    'simple_source'
                );
                // Crear enlaces desde energ√©ticos primarios
                // Despu√©s de crear los nodos de energ√≠a primaria y tener el mapa energeticNodesMap

                // --- Crear enlaces desde los nodos de energ√≠a primaria al nodo Industrial ---
                if (industrialNodeData && industrialNodeData['Nodos Hijo']) {
                    industrialNodeData['Nodos Hijo'].forEach(hijo => {
                        if (hijo.tipo === 'Energ√≠a Primaria' && hijo[year] > 0) {
                            const sourceNodeIndex = energeticNodesMap.get(hijo['Nodo Hijo']);
                            const industrialNodeIndex = nodeMap.get(industrialNodeData['Nodo Padre']);

                            if (sourceNodeIndex !== undefined && industrialNodeIndex !== undefined) {
                                const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || hijo.color || '#999999';
                                const linkValue = Math.log10(parseFloat(hijo[year]) + 1);

                                source.push(sourceNodeIndex);
                                target.push(industrialNodeIndex);
                                value.push(linkValue);
                                linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                                // Crear el popup para el enlace
                                linkCustomdata.push(popupManager.generateLinkPopup(
                                    hijo['Nodo Hijo'],
                                    parseFloat(hijo[year]),
                                    hijo['Nodo Hijo'],
                                    industrialNodeData['Nodo Padre'],
                                    linkColor,
                                    year,
                                    {
                                        flowType: 'sector_industrial',
                                        template: 'simple'
                                    }
                                ));
                            }
                        }
                    });
                }


                // Crear enlaces desde energ√©ticos secundarios
                industrialNodeData['Nodos Hijo'].forEach(hijo => {
                    if (hijo.tipo === 'Energ√≠a Secundaria' && hijo[year] > 0) {
                        const sourceNodeIndex = secondaryEnergeticNodesMap.get(hijo['Nodo Hijo']);
                        if (sourceNodeIndex !== undefined) {
                            const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || '#999999';

                            source.push(sourceNodeIndex);
                            target.push(industrialIndex);
                            value.push(Math.log10(hijo[year] + 1));
                            linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                            linkCustomdata.push(popupManager.generateLinkPopup(
                                hijo['Nodo Hijo'],
                                hijo[year],
                                hijo['Nodo Hijo'],
                                'Industrial',
                                linkColor,
                                year,
                                { flowType: 'to_industrial_secondary' }
                            ));
                        }
                    }
                });
            }

            // --- NODO TRANSPORTE ---
            const transporteNodeData = dataManager.getNodeData('Transporte');
            if (transporteNodeData && transporteNodeData['Nodos Hijo']) {
                // Crear nodo Transporte
                const transporteIndex = addNode(transporteNodeData['Nodo Padre'], transporteNodeData.color);
                nodeX[transporteIndex] = 0.9;
                nodeY[transporteIndex] = 0.3;

                // Calcular el total sumando los valores de los hijos
                const totalTransporte = transporteNodeData['Nodos Hijo'].reduce((sum, hijo) => {
                    return sum + (parseFloat(hijo[year]) || 0);
                }, 0);

                // Crear un objeto con el formato esperado por la plantilla simple_source
                const popupData = {
                    label: 'Sector Transporte',  // Cambiamos esto
                    total: totalTransporte,
                    unit: 'PJ' // Ajusta la unidad seg√∫n corresponda
                };

                // Generar el popup
                nodeCustomdata[transporteIndex] = popupManager.generateNodePopup(
                    'Sector Transporte',  // Y aqu√≠ tambi√©n
                    popupData,  // Pasamos los datos formateados
                    year,
                    popupData,  // Mismos datos para el desglose
                    'text',
                    'Todos',
                    'simple_source'
                );
                // Crear enlaces desde energ√©ticos primarios
                // Despu√©s de crear los nodos de energ√≠a primaria y tener el mapa energeticNodesMap

                // --- Crear enlaces desde los nodos de energ√≠a primaria al nodo Industrial ---
                if (transporteNodeData && transporteNodeData['Nodos Hijo']) {
                    transporteNodeData['Nodos Hijo'].forEach(hijo => {
                        if (hijo.tipo === 'Energ√≠a Primaria' && hijo[year] > 0) {
                            const sourceNodeIndex = energeticNodesMap.get(hijo['Nodo Hijo']);
                            const transporteNodeIndex = nodeMap.get(transporteNodeData['Nodo Padre']);

                            if (sourceNodeIndex !== undefined && transporteNodeIndex !== undefined) {
                                const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || hijo.color || '#999999';
                                const linkValue = Math.log10(parseFloat(hijo[year]) + 1);

                                source.push(sourceNodeIndex);
                                target.push(transporteNodeIndex);
                                value.push(linkValue);
                                linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                                // Crear el popup para el enlace
                                linkCustomdata.push(popupManager.generateLinkPopup(
                                    hijo['Nodo Hijo'],
                                    parseFloat(hijo[year]),
                                    hijo['Nodo Hijo'],
                                    transporteNodeData['Nodo Padre'],
                                    linkColor,
                                    year,
                                    {
                                        flowType: 'sector_industrial',
                                        template: 'simple'
                                    }
                                ));
                            }
                        }
                    });
                }


                // Crear enlaces desde energ√©ticos secundarios
                transporteNodeData['Nodos Hijo'].forEach(hijo => {
                    if (hijo.tipo === 'Energ√≠a Secundaria' && hijo[year] > 0) {
                        const sourceNodeIndex = secondaryEnergeticNodesMap.get(hijo['Nodo Hijo']);
                        if (sourceNodeIndex !== undefined) {
                            const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || '#999999';

                            source.push(sourceNodeIndex);
                            target.push(transporteIndex);
                            value.push(Math.log10(hijo[year] + 1));
                            linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                            linkCustomdata.push(popupManager.generateLinkPopup(
                                hijo['Nodo Hijo'],
                                hijo[year],
                                hijo['Nodo Hijo'],
                                'Transporte',
                                linkColor,
                                year,
                                { flowType: 'to_transporte_secondary' }
                            ));
                        }
                    }
                });
            }

            // --- NODO AGROPECUARIO ---
            const agropecuarioNodeData = dataManager.getNodeData('Agropecuario');
            if (agropecuarioNodeData && agropecuarioNodeData['Nodos Hijo']) {
                // Crear nodo Agropecuario
                const agropecuarioIndex = addNode(agropecuarioNodeData['Nodo Padre'], agropecuarioNodeData.color);
                nodeX[agropecuarioIndex] = 0.9;
                nodeY[agropecuarioIndex] = 0.4;

                // Calcular el total sumando los valores de los hijos
                const totalAgropecuario = agropecuarioNodeData['Nodos Hijo'].reduce((sum, hijo) => {
                    return sum + (parseFloat(hijo[year]) || 0);
                }, 0);

                // Crear un objeto con el formato esperado por la plantilla simple_source
                const popupData = {
                    label: 'Sector Agropecuario',  // Cambiamos esto
                    total: totalAgropecuario,
                    unit: 'PJ' // Ajusta la unidad seg√∫n corresponda
                };

                // Generar el popup
                nodeCustomdata[agropecuarioIndex] = popupManager.generateNodePopup(
                    'Sector Agropecuario',  // Y aqu√≠ tambi√©n
                    popupData,  // Pasamos los datos formateados
                    year,
                    popupData,  // Mismos datos para el desglose
                    'text',
                    'Todos',
                    'simple_source'
                );
                // Crear enlaces desde energ√©ticos primarios
                agropecuarioNodeData['Nodos Hijo'].forEach(hijo => {
                    if (hijo.tipo === 'Energ√≠a Primaria' && hijo[year] > 0) {
                        const sourceNodeIndex = primaryEnergeticNodesMap.get(hijo['Nodo Hijo']);
                        if (sourceNodeIndex !== undefined) {
                            const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || '#999999';

                            source.push(sourceNodeIndex);
                            target.push(agropecuarioIndex);
                            value.push(Math.log10(hijo[year] + 1));
                            linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                            linkCustomdata.push(popupManager.generateLinkPopup(
                                hijo['Nodo Hijo'],
                                hijo[year],
                                hijo['Nodo Hijo'],
                                'Agropecuario',
                                linkColor,
                                year,
                                { flowType: 'to_agropecuario' }
                            ));
                        }
                    }
                });

                // Crear enlaces desde energ√©ticos secundarios
                agropecuarioNodeData['Nodos Hijo'].forEach(hijo => {
                    if (hijo.tipo === 'Energ√≠a Secundaria' && hijo[year] > 0) {
                        const sourceNodeIndex = secondaryEnergeticNodesMap.get(hijo['Nodo Hijo']);
                        if (sourceNodeIndex !== undefined) {
                            const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || '#999999';

                            source.push(sourceNodeIndex);
                            target.push(agropecuarioIndex);
                            value.push(Math.log10(hijo[year] + 1));
                            linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                            linkCustomdata.push(popupManager.generateLinkPopup(
                                hijo['Nodo Hijo'],
                                hijo[year],
                                hijo['Nodo Hijo'],
                                'Agropecuario',
                                linkColor,
                                year,
                                { flowType: 'to_agropecuario_secondary' }
                            ));
                        }
                    }
                });
            }

            // --- NODO COMERCIAL ---
            const comercialNodeData = dataManager.getNodeData('Comercial');
            if (comercialNodeData && comercialNodeData['Nodos Hijo']) {
                // Crear nodo Transporte
                const comercialIndex = addNode(comercialNodeData['Nodo Padre'], comercialNodeData.color);
                nodeX[comercialIndex] = 0.9;
                nodeY[comercialIndex] = 0.5;

                // Calcular el total sumando los valores de los hijos
                const totalComercial = comercialNodeData['Nodos Hijo'].reduce((sum, hijo) => {
                    return sum + (parseFloat(hijo[year]) || 0);
                }, 0);

                // Crear un objeto con el formato esperado por la plantilla simple_source
                const popupData = {
                    label: 'Sector Comercial',  // Cambiamos esto
                    total: totalComercial,
                    unit: 'PJ' // Ajusta la unidad seg√∫n corresponda
                };

                // Generar el popup
                nodeCustomdata[comercialIndex] = popupManager.generateNodePopup(
                    'Sector Comercial',  // Y aqu√≠ tambi√©n
                    popupData,  // Pasamos los datos formateados
                    year,
                    popupData,  // Mismos datos para el desglose
                    'text',
                    'Todos',
                    'simple_source'
                );
                // Crear enlaces desde energ√©ticos primarios
                // Despu√©s de crear los nodos de energ√≠a primaria y tener el mapa energeticNodesMap

                // --- Crear enlaces desde los nodos de energ√≠a primaria al nodo Industrial ---
                if (comercialNodeData && comercialNodeData['Nodos Hijo']) {
                    comercialNodeData['Nodos Hijo'].forEach(hijo => {
                        if (hijo.tipo === 'Energ√≠a Primaria' && hijo[year] > 0) {
                            const sourceNodeIndex = energeticNodesMap.get(hijo['Nodo Hijo']);
                            const comercialNodeIndex = nodeMap.get(comercialNodeData['Nodo Padre']);

                            if (sourceNodeIndex !== undefined && comercialNodeIndex !== undefined) {
                                const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || hijo.color || '#999999';
                                const linkValue = Math.log10(parseFloat(hijo[year]) + 1);

                                source.push(sourceNodeIndex);
                                target.push(comercialNodeIndex);
                                value.push(linkValue);
                                linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                                // Crear el popup para el enlace
                                linkCustomdata.push(popupManager.generateLinkPopup(
                                    hijo['Nodo Hijo'],
                                    parseFloat(hijo[year]),
                                    hijo['Nodo Hijo'],
                                    comercialNodeData['Nodo Padre'],
                                    linkColor,
                                    year,
                                    {
                                        flowType: 'sector_industrial',
                                        template: 'simple'
                                    }
                                ));
                            }
                        }
                    });
                }


                // Crear enlaces desde energ√©ticos secundarios
                comercialNodeData['Nodos Hijo'].forEach(hijo => {
                    if (hijo.tipo === 'Energ√≠a Secundaria' && hijo[year] > 0) {
                        const sourceNodeIndex = secondaryEnergeticNodesMap.get(hijo['Nodo Hijo']);
                        if (sourceNodeIndex !== undefined) {
                            const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || '#999999';

                            source.push(sourceNodeIndex);
                            target.push(comercialIndex);
                            value.push(Math.log10(hijo[year] + 1));
                            linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                            linkCustomdata.push(popupManager.generateLinkPopup(
                                hijo['Nodo Hijo'],
                                hijo[year],
                                hijo['Nodo Hijo'],
                                'Comercial',
                                linkColor,
                                year,
                                { flowType: 'to_comercial_secondary' }
                            ));
                        }
                    }
                });
            }

            //-----------------------------------------
            // --- NODO P√öBLICO ---
            const publicoNodeData = dataManager.getNodeData('P√∫blico');
            if (publicoNodeData && publicoNodeData['Nodos Hijo']) {
                // Crear nodo Transporte
                const publicoIndex = addNode(publicoNodeData['Nodo Padre'], publicoNodeData.color);
                nodeX[publicoIndex] = 0.9;
                nodeY[publicoIndex] = 0.6;

                // Calcular el total sumando los valores de los hijos
                const totalPublico = publicoNodeData['Nodos Hijo'].reduce((sum, hijo) => {
                    return sum + (parseFloat(hijo[year]) || 0);
                }, 0);

                // Crear un objeto con el formato esperado por la plantilla simple_source
                const popupData = {
                    label: 'Sector P√∫blico',  // Cambiamos esto
                    total: totalPublico,
                    unit: 'PJ' // Ajusta la unidad seg√∫n corresponda
                };

                // Generar el popup
                nodeCustomdata[publicoIndex] = popupManager.generateNodePopup(
                    'Sector P√∫blico',  // Y aqu√≠ tambi√©n
                    popupData,  // Pasamos los datos formateados
                    year,
                    popupData,  // Mismos datos para el desglose
                    'text',
                    'Todos',
                    'simple_source'
                );
                // Crear enlaces desde energ√©ticos primarios
                // Despu√©s de crear los nodos de energ√≠a primaria y tener el mapa energeticNodesMap

                // --- Crear enlaces desde los nodos de energ√≠a primaria al nodo Industrial ---
                if (publicoNodeData && publicoNodeData['Nodos Hijo']) {
                    publicoNodeData['Nodos Hijo'].forEach(hijo => {
                        if (hijo.tipo === 'Energ√≠a Primaria' && hijo[year] > 0) {
                            const sourceNodeIndex = energeticNodesMap.get(hijo['Nodo Hijo']);
                            const publicoNodeIndex = nodeMap.get(publicoNodeData['Nodo Padre']);

                            if (sourceNodeIndex !== undefined && publicoNodeIndex !== undefined) {
                                const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || hijo.color || '#999999';
                                const linkValue = Math.log10(parseFloat(hijo[year]) + 1);

                                source.push(sourceNodeIndex);
                                target.push(publicoNodeIndex);
                                value.push(linkValue);
                                linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                                // Crear el popup para el enlace
                                linkCustomdata.push(popupManager.generateLinkPopup(
                                    hijo['Nodo Hijo'],
                                    parseFloat(hijo[year]),
                                    hijo['Nodo Hijo'],
                                    publicoNodeData['Nodo Padre'],
                                    linkColor,
                                    year,
                                    {
                                        flowType: 'sector_industrial',
                                        template: 'simple'
                                    }
                                ));
                            }
                        }
                    });
                }


                // Crear enlaces desde energ√©ticos secundarios
                publicoNodeData['Nodos Hijo'].forEach(hijo => {
                    if (hijo.tipo === 'Energ√≠a Secundaria' && hijo[year] > 0) {
                        const sourceNodeIndex = secondaryEnergeticNodesMap.get(hijo['Nodo Hijo']);
                        if (sourceNodeIndex !== undefined) {
                            const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || '#999999';

                            source.push(sourceNodeIndex);
                            target.push(publicoIndex);
                            value.push(Math.log10(hijo[year] + 1));
                            linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                            linkCustomdata.push(popupManager.generateLinkPopup(
                                hijo['Nodo Hijo'],
                                hijo[year],
                                hijo['Nodo Hijo'],
                                'P√∫blico',
                                linkColor,
                                year,
                                { flowType: 'to_publico_secondary' }
                            ));
                        }
                    }
                });
            }


            // --- NODO RESIDENCIAL ---
            const residencialNodeData = dataManager.getNodeData('Residencial');
            if (residencialNodeData && residencialNodeData['Nodos Hijo']) {
                // Crear nodo Transporte
                const residencialIndex = addNode(residencialNodeData['Nodo Padre'], residencialNodeData.color);
                nodeX[residencialIndex] = 0.9;
                nodeY[residencialIndex] = 0.7;

                // Calcular el total sumando los valores de los hijos
                const totalResidencial = residencialNodeData['Nodos Hijo'].reduce((sum, hijo) => {
                    return sum + (parseFloat(hijo[year]) || 0);
                }, 0);

                // Crear un objeto con el formato esperado por la plantilla simple_source
                const popupData = {
                    label: 'Sector Residencial',  // Cambiamos esto
                    total: totalResidencial,
                    unit: 'PJ' // Ajusta la unidad seg√∫n corresponda
                };

                // Generar el popup
                nodeCustomdata[residencialIndex] = popupManager.generateNodePopup(
                    'Sector Residencial',  // Y aqu√≠ tambi√©n
                    popupData,  // Pasamos los datos formateados
                    year,
                    popupData,  // Mismos datos para el desglose
                    'text',
                    'Todos',
                    'simple_source'
                );
                // Crear enlaces desde energ√©ticos primarios
                // Despu√©s de crear los nodos de energ√≠a primaria y tener el mapa energeticNodesMap

                // --- Crear enlaces desde los nodos de energ√≠a primaria al nodo Industrial ---
                if (residencialNodeData && residencialNodeData['Nodos Hijo']) {
                    residencialNodeData['Nodos Hijo'].forEach(hijo => {
                        if (hijo.tipo === 'Energ√≠a Primaria' && hijo[year] > 0) {
                            const sourceNodeIndex = energeticNodesMap.get(hijo['Nodo Hijo']);
                            const publicoNodeIndex = nodeMap.get(residencialNodeData['Nodo Padre']);

                            if (sourceNodeIndex !== undefined && publicoNodeIndex !== undefined) {
                                const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || hijo.color || '#999999';
                                const linkValue = Math.log10(parseFloat(hijo[year]) + 1);

                                source.push(sourceNodeIndex);
                                target.push(publicoNodeIndex);
                                value.push(linkValue);
                                linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                                // Crear el popup para el enlace
                                linkCustomdata.push(popupManager.generateLinkPopup(
                                    hijo['Nodo Hijo'],
                                    parseFloat(hijo[year]),
                                    hijo['Nodo Hijo'],
                                    residencialNodeData['Nodo Padre'],
                                    linkColor,
                                    year,
                                    {
                                        flowType: 'sector_industrial',
                                        template: 'simple'
                                    }
                                ));
                            }
                        }
                    });
                }


                // Crear enlaces desde energ√©ticos secundarios
                residencialNodeData['Nodos Hijo'].forEach(hijo => {
                    if (hijo.tipo === 'Energ√≠a Secundaria' && hijo[year] > 0) {
                        const sourceNodeIndex = secondaryEnergeticNodesMap.get(hijo['Nodo Hijo']);
                        if (sourceNodeIndex !== undefined) {
                            const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || '#999999';

                            source.push(sourceNodeIndex);
                            target.push(residencialIndex);
                            value.push(Math.log10(hijo[year] + 1));
                            linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                            linkCustomdata.push(popupManager.generateLinkPopup(
                                hijo['Nodo Hijo'],
                                hijo[year],
                                hijo['Nodo Hijo'],
                                'Residencial',
                                linkColor,
                                year,
                                { flowType: 'to_residencial_secondary' }
                            ));
                        }
                    }
                });
            }

            // --- NODO Petroqu√≠mica Pemex ---
            const petroquimicaNodeData = dataManager.getNodeData('Petroqu√≠mica Pemex');
            if (petroquimicaNodeData && petroquimicaNodeData['Nodos Hijo']) {
                // Crear nodo Transporte
                const petroquimicaIndex = addNode(petroquimicaNodeData['Nodo Padre'], petroquimicaNodeData.color);
                nodeX[petroquimicaIndex] = 0.9;
                nodeY[petroquimicaIndex] = 0.8;

                // Calcular el total sumando los valores de los hijos
                const totalPetroquimica = petroquimicaNodeData['Nodos Hijo'].reduce((sum, hijo) => {
                    return sum + (parseFloat(hijo[year]) || 0);
                }, 0);

                // Crear un objeto con el formato esperado por la plantilla simple_source
                const popupData = {
                    label: 'Sector Petroqu√≠mica Pemex',  // Cambiamos esto
                    total: totalPetroquimica,
                    unit: 'PJ' // Ajusta la unidad seg√∫n corresponda
                };

                // Generar el popup
                nodeCustomdata[petroquimicaIndex] = popupManager.generateNodePopup(
                    'Sector Petroqu√≠mica Pemex',  // Y aqu√≠ tambi√©n
                    popupData,  // Pasamos los datos formateados
                    year,
                    popupData,  // Mismos datos para el desglose
                    'text',
                    'Todos',
                    'simple_source'
                );
                // Crear enlaces desde energ√©ticos primarios
                // Despu√©s de crear los nodos de energ√≠a primaria y tener el mapa energeticNodesMap

                // --- Crear enlaces desde los nodos de energ√≠a primaria al nodo Industrial ---
                if (petroquimicaNodeData && petroquimicaNodeData['Nodos Hijo']) {
                    petroquimicaNodeData['Nodos Hijo'].forEach(hijo => {
                        if (hijo.tipo === 'Energ√≠a Primaria' && hijo[year] > 0) {
                            const sourceNodeIndex = energeticNodesMap.get(hijo['Nodo Hijo']);
                            const publicoNodeIndex = nodeMap.get(petroquimicaNodeData['Nodo Padre']);

                            if (sourceNodeIndex !== undefined && publicoNodeIndex !== undefined) {
                                const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || hijo.color || '#999999';
                                const linkValue = Math.log10(parseFloat(hijo[year]) + 1);

                                source.push(sourceNodeIndex);
                                target.push(publicoNodeIndex);
                                value.push(linkValue);
                                linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                                // Crear el popup para el enlace
                                linkCustomdata.push(popupManager.generateLinkPopup(
                                    hijo['Nodo Hijo'],
                                    parseFloat(hijo[year]),
                                    hijo['Nodo Hijo'],
                                    petroquimicaNodeData['Nodo Padre'],
                                    linkColor,
                                    year,
                                    {
                                        flowType: 'sector_industrial',
                                        template: 'simple'
                                    }
                                ));
                            }
                        }
                    });
                }


                // Crear enlaces desde energ√©ticos secundarios
                petroquimicaNodeData['Nodos Hijo'].forEach(hijo => {
                    if (hijo.tipo === 'Energ√≠a Secundaria' && hijo[year] > 0) {
                        const sourceNodeIndex = secondaryEnergeticNodesMap.get(hijo['Nodo Hijo']);
                        if (sourceNodeIndex !== undefined) {
                            const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || '#999999';

                            source.push(sourceNodeIndex);
                            target.push(petroquimicaIndex);
                            value.push(Math.log10(hijo[year] + 1));
                            linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                            linkCustomdata.push(popupManager.generateLinkPopup(
                                hijo['Nodo Hijo'],
                                hijo[year],
                                hijo['Nodo Hijo'],
                                'Petroqu√≠mica Pemex',
                                linkColor,
                                year,
                                { flowType: 'to_petroquimica_secondary' }
                            ));
                        }
                    }
                });
            }


            // --- NODO Otras ramas econ√≥micas ---
            const otrasRamasEconomicasNodeData = dataManager.getNodeData('Otras ramas econ√≥micas');
            if (otrasRamasEconomicasNodeData && otrasRamasEconomicasNodeData['Nodos Hijo']) {
                // Crear nodo Transporte
                const otrasRamasEconomicasIndex = addNode(otrasRamasEconomicasNodeData['Nodo Padre'], otrasRamasEconomicasNodeData.color);
                nodeX[otrasRamasEconomicasIndex] = 0.9;
                nodeY[otrasRamasEconomicasIndex] = 0.85;

                // Calcular el total sumando los valores de los hijos
                const totalOtrasRamasEconomicas = otrasRamasEconomicasNodeData['Nodos Hijo'].reduce((sum, hijo) => {
                    return sum + (parseFloat(hijo[year]) || 0);
                }, 0);

                // Crear un objeto con el formato esperado por la plantilla simple_source
                const popupData = {
                    label: 'Sector Otras ramas econ√≥micas',  // Cambiamos esto
                    total: totalOtrasRamasEconomicas,
                    unit: 'PJ' // Ajusta la unidad seg√∫n corresponda
                };

                // Generar el popup
                nodeCustomdata[otrasRamasEconomicasIndex] = popupManager.generateNodePopup(
                    'Sector Otras ramas econ√≥micas',  // Y aqu√≠ tambi√©n
                    popupData,  // Pasamos los datos formateados
                    year,
                    popupData,  // Mismos datos para el desglose
                    'text',
                    'Todos',
                    'simple_source'
                );
                // Crear enlaces desde energ√©ticos primarios
                // Despu√©s de crear los nodos de energ√≠a primaria y tener el mapa energeticNodesMap

                // --- Crear enlaces desde los nodos de energ√≠a primaria al nodo Industrial ---
                if (otrasRamasEconomicasNodeData && otrasRamasEconomicasNodeData['Nodos Hijo']) {
                    otrasRamasEconomicasNodeData['Nodos Hijo'].forEach(hijo => {
                        if (hijo.tipo === 'Energ√≠a Primaria' && hijo[year] > 0) {
                            const sourceNodeIndex = energeticNodesMap.get(hijo['Nodo Hijo']);
                            const publicoNodeIndex = nodeMap.get(otrasRamasEconomicasNodeData['Nodo Padre']);

                            if (sourceNodeIndex !== undefined && publicoNodeIndex !== undefined) {
                                const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || hijo.color || '#999999';
                                const linkValue = Math.log10(parseFloat(hijo[year]) + 1);

                                source.push(sourceNodeIndex);
                                target.push(publicoNodeIndex);
                                value.push(linkValue);
                                linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                                // Crear el popup para el enlace
                                linkCustomdata.push(popupManager.generateLinkPopup(
                                    hijo['Nodo Hijo'],
                                    parseFloat(hijo[year]),
                                    hijo['Nodo Hijo'],
                                    otrasRamasEconomicasNodeData['Nodo Padre'],
                                    linkColor,
                                    year,
                                    {
                                        flowType: 'sector_industrial',
                                        template: 'simple'
                                    }
                                ));
                            }
                        }
                    });
                }


                // Crear enlaces desde energ√©ticos secundarios
                otrasRamasEconomicasNodeData['Nodos Hijo'].forEach(hijo => {
                    if (hijo.tipo === 'Energ√≠a Secundaria' && hijo[year] > 0) {
                        const sourceNodeIndex = secondaryEnergeticNodesMap.get(hijo['Nodo Hijo']);
                        if (sourceNodeIndex !== undefined) {
                            const linkColor = styleManager.getEnergyColor(hijo['Nodo Hijo']) || '#999999';

                            source.push(sourceNodeIndex);
                            target.push(otrasRamasEconomicasIndex);
                            value.push(Math.log10(hijo[year] + 1));
                            linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                            linkCustomdata.push(popupManager.generateLinkPopup(
                                hijo['Nodo Hijo'],
                                hijo[year],
                                hijo['Nodo Hijo'],
                                'Otras ramas econ√≥micas',
                                linkColor,
                                year,
                                { flowType: 'to_otras_Ramas_economicas_secondary' }
                            ));
                        }
                    }
                });
            }





            //---------
            // --- Y AQU√ç GENERAREMOS LOS ENLACES ---
            // Enlaces de Importaci√≥n a energ√©ticos primarios de Oferta Interna Bruta
            if (importacionNodeData && ofertaInternaBrutaFullData && ofertaInternaBrutaFullData['Nodos Hijo']) {
                const primaryEnergeticsInOIB = ofertaInternaBrutaFullData['Nodos Hijo'].filter(child => child.tipo === 'Energ√≠a Primaria');

                primaryEnergeticsInOIB.forEach(energetic => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticValueFromImportacion = dataManager.getEnergeticValue('Importaci√≥n', energeticName, year);

                    if (energeticValueFromImportacion !== null && energeticValueFromImportacion > 0) {
                        const linkColor = styleManager.getEnergyColor(energeticName) || energetic.color;
                        console.log(`[DEBUG - Enlace Importaci√≥n]Energ√©tico: ${energeticName}, Color de enlace: ${linkColor} `);
                        source.push(nodeMap.get('Importaci√≥n'));
                        target.push(energeticNodesMap.get(energeticName));
                        value.push(Math.log10(energeticValueFromImportacion + 1));
                        linkColors.push(styleManager.hexToRgba(linkColor, 0.5));
                        linkCustomdata.push(popupManager.generateLinkPopup(
                            energeticName, energeticValueFromImportacion, 'Importaci√≥n', energeticName, linkColor, year,
                            { flowType: 'primary_supply' }
                        ));
                    }
                });
            }

            // Enlaces de Producci√≥n a energ√©ticos primarios de Oferta Interna Bruta
            if (produccionNodeData && ofertaInternaBrutaFullData && ofertaInternaBrutaFullData['Nodos Hijo']) {
                const primaryEnergeticsInOIB = ofertaInternaBrutaFullData['Nodos Hijo'].filter(child => child.tipo === 'Energ√≠a Primaria');

                primaryEnergeticsInOIB.forEach(energetic => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticValueFromProduccion = dataManager.getEnergeticValue('Producci√≥n', energeticName, year);

                    if (energeticValueFromProduccion !== null && energeticValueFromProduccion > 0) {
                        const linkColor = styleManager.getEnergyColor(energeticName) || energetic.color;
                        console.log(`[DEBUG - Enlace Producci√≥n]Energ√©tico: ${energeticName}, Color de enlace: ${linkColor} `);
                        source.push(nodeMap.get('Producci√≥n'));
                        target.push(energeticNodesMap.get(energeticName));
                        value.push(Math.log10(energeticValueFromProduccion + 1));
                        linkColors.push(styleManager.hexToRgba(linkColor, 0.5));
                        linkCustomdata.push(popupManager.generateLinkPopup(
                            energeticName, energeticValueFromProduccion, 'Producci√≥n', energeticName, linkColor, year,
                            { flowType: 'primary_supply' }
                        ));
                    }
                });
            }

            // Enlaces de Variaci√≥n de Inventarios a energ√©ticos primarios de Oferta Interna Bruta
            if (variacionNodeData && ofertaInternaBrutaFullData && ofertaInternaBrutaFullData['Nodos Hijo']) {
                const primaryEnergeticsInOIB = ofertaInternaBrutaFullData['Nodos Hijo'].filter(child => child.tipo === 'Energ√≠a Primaria');

                primaryEnergeticsInOIB.forEach(energetic => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticValueFromVariacion = dataManager.getEnergeticValue('Variaci√≥n de Inventarios', energeticName, year);

                    // Los valores de variaci√≥n pueden ser negativos, pero Plotly espera valores positivos para `value`
                    // El signo se manejar√° en el popup.
                    if (energeticValueFromVariacion !== null && Math.abs(energeticValueFromVariacion) > 0) {
                        const linkColor = styleManager.getEnergyColor(energeticName) || energetic.color;
                        console.log(`[DEBUG - Enlace Variaci√≥n]Energ√©tico: ${energeticName}, Color de enlace: ${linkColor} `);
                        source.push(nodeMap.get('Variaci√≥n de Inventarios'));
                        target.push(energeticNodesMap.get(energeticName));
                        value.push(Math.log10(Math.abs(energeticValueFromVariacion) + 1));
                        linkColors.push(styleManager.hexToRgba(linkColor, 0.5));
                        linkCustomdata.push(popupManager.generateLinkPopup(
                            energeticName, energeticValueFromVariacion, 'Variaci√≥n de Inventarios', energeticName, linkColor, year,
                            { flowType: 'primary_supply' }
                        ));
                    }
                });
            }

            // Enlaces de energ√©ticos primarios a Exportaci√≥n
            if (coquizadorasyhornosNodeData && ofertaInternaBrutaFullData && ofertaInternaBrutaFullData['Nodos Hijo']) {
                const primaryEnergeticsInOIB = ofertaInternaBrutaFullData['Nodos Hijo'].filter(child => child.tipo === 'Energ√≠a Primaria');

                primaryEnergeticsInOIB.forEach(energetic => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticValueToExportacion = dataManager.getEnergeticValue('Exportaci√≥n', energeticName, year);
                    console.log(`[DEBUG - Flujo Exportaci√≥n] ${energeticName}: ${energeticValueToExportacion} `);
                    if (energeticValueToExportacion !== null && Math.abs(energeticValueToExportacion) > 0) {
                        const linkColor = styleManager.getEnergyColor(energeticName) || energetic.color;
                        console.log(`[DEBUG - Enlace Exportaci√≥n]Energ√©tico: ${energeticName}, Color de enlace: ${linkColor} `);
                        source.push(energeticNodesMap.get(energeticName));
                        target.push(nodeMap.get('Exportaci√≥n'));
                        value.push(Math.log10(Math.abs(energeticValueToExportacion) + 1));
                        linkColors.push(styleManager.hexToRgba(linkColor, 0.5));
                        linkCustomdata.push(popupManager.generateLinkPopup(
                            energeticName, energeticValueToExportacion, energeticName, 'Exportaci√≥n', linkColor, year,
                            { flowType: 'primary_demand' }
                        ));
                    }
                });
            }

            // Enlaces de energ√©ticos primarios a Energ√≠a No Aprovechada
            if (energiaNoAprovechadaNodeData && ofertaInternaBrutaFullData && ofertaInternaBrutaFullData['Nodos Hijo']) {
                const primaryEnergeticsInOIB = ofertaInternaBrutaFullData['Nodos Hijo'].filter(child => child.tipo === 'Energ√≠a Primaria');

                primaryEnergeticsInOIB.forEach(energetic => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticValueToNoAprovechada = dataManager.getEnergeticValue('Energ√≠a No Aprovechada', energeticName, year);
                    console.log(`[DEBUG - Flujo Energ√≠a No Aprovechada] ${energeticName}: ${energeticValueToNoAprovechada} `);
                    if (energeticValueToNoAprovechada !== null && Math.abs(energeticValueToNoAprovechada) > 0) {
                        const linkColor = styleManager.getEnergyColor(energeticName) || energetic.color;
                        console.log(`[DEBUG - Enlace Energ√≠a No Aprovechada]Energ√©tico: ${energeticName}, Color de enlace: ${linkColor} `);
                        source.push(energeticNodesMap.get(energeticName));
                        target.push(nodeMap.get('Energ√≠a No Aprovechada'));
                        value.push(Math.log10(Math.abs(energeticValueToNoAprovechada) + 1));
                        linkColors.push(styleManager.hexToRgba(linkColor, 0.5));
                        linkCustomdata.push(popupManager.generateLinkPopup(
                            energeticName, energeticValueToNoAprovechada, energeticName, 'Energ√≠a No Aprovechada', linkColor, year,
                            { flowType: 'primary_demand' }
                        ));
                    }
                });
            }


            // Enlaces de energ√©ticos primarios a Coquizadoras y Hornos
            if (coquizadorasyhornosNodeData && ofertaInternaBrutaFullData && ofertaInternaBrutaFullData['Nodos Hijo']) {
                const primaryEnergeticsInOIB = ofertaInternaBrutaFullData['Nodos Hijo'].filter(child => child.tipo === 'Energ√≠a Primaria');

                primaryEnergeticsInOIB.forEach(energetic => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticValueToExportacion = dataManager.getEnergeticValue('Coquizadoras y Hornos', energeticName, year);
                    console.log(`[DEBUG - Flujo Coquizadoras y Hornos] ${energeticName}: ${energeticValueToExportacion} `);
                    if (energeticValueToExportacion !== null && Math.abs(energeticValueToExportacion) > 0) {
                        const linkColor = styleManager.getEnergyColor(energeticName) || energetic.color;
                        console.log(`[DEBUG - Enlace Coquizadoras y Hornos]Energ√©tico: ${energeticName}, Color de enlace: ${linkColor} `);
                        source.push(energeticNodesMap.get(energeticName));
                        target.push(nodeMap.get('Coquizadoras y Hornos'));
                        value.push(Math.log10(Math.abs(energeticValueToExportacion) + 1));
                        linkColors.push(styleManager.hexToRgba(linkColor, 0.5));
                        linkCustomdata.push(popupManager.generateLinkPopup(
                            energeticName, energeticValueToExportacion, energeticName, 'Coquizadoras y Hornos', linkColor, year,
                            { flowType: 'primary_demand' }
                        ));
                    }
                });
            }

            // Enlaces de energ√©ticos primarios a Plantas de Gas y Fraccionadoras
            if (plantasdegasyfraccionadorasNodeData && ofertaInternaBrutaFullData && ofertaInternaBrutaFullData['Nodos Hijo']) {
                const primaryEnergeticsInOIB = ofertaInternaBrutaFullData['Nodos Hijo'].filter(child => child.tipo === 'Energ√≠a Primaria');

                primaryEnergeticsInOIB.forEach(energetic => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticValueToExportacion = dataManager.getEnergeticValue('Plantas de Gas y Fraccionadoras', energeticName, year);
                    console.log(`[DEBUG - Flujo Plantas de Gas y Fraccionadoras] ${energeticName}: ${energeticValueToExportacion} `);
                    if (energeticValueToExportacion !== null && Math.abs(energeticValueToExportacion) > 0) {
                        const linkColor = styleManager.getEnergyColor(energeticName) || energetic.color;
                        console.log(`[DEBUG - Enlace Plantas de Gas y Fraccionadoras]Energ√©tico: ${energeticName}, Color de enlace: ${linkColor} `);
                        source.push(energeticNodesMap.get(energeticName));
                        target.push(nodeMap.get('Plantas de Gas y Fraccionadoras'));
                        value.push(Math.log10(Math.abs(energeticValueToExportacion) + 1));
                        linkColors.push(styleManager.hexToRgba(linkColor, 0.5));
                        linkCustomdata.push(popupManager.generateLinkPopup(
                            energeticName, energeticValueToExportacion, energeticName, 'Plantas de Gas y Fraccionadoras', linkColor, year,
                            { flowType: 'primary_demand' }
                        ));
                    }
                });
            }

            // Enlaces de energ√©ticos primarios a Refiner√≠as y Despuntadoras
            if (refinerasydespuntadorasNodeData && ofertaInternaBrutaFullData && ofertaInternaBrutaFullData['Nodos Hijo']) {
                const primaryEnergeticsInOIB = ofertaInternaBrutaFullData['Nodos Hijo'].filter(child => child.tipo === 'Energ√≠a Primaria');

                primaryEnergeticsInOIB.forEach(energetic => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticValueToRefinerasydespuntadoras = dataManager.getEnergeticValue('Refiner√≠as y Despuntadoras', energeticName, year);
                    console.log(`[DEBUG - Flujo Refiner√≠as y Despuntadoras] ${energeticName}: ${energeticValueToRefinerasydespuntadoras} `);
                    if (energeticValueToRefinerasydespuntadoras !== null && Math.abs(energeticValueToRefinerasydespuntadoras) > 0) {
                        const linkColor = styleManager.getEnergyColor(energeticName) || energetic.color;
                        console.log(`[DEBUG - Enlace Refiner√≠as y Despuntadoras]Energ√©tico: ${energeticName}, Color de enlace: ${linkColor} `);
                        source.push(energeticNodesMap.get(energeticName));
                        target.push(nodeMap.get('Refiner√≠as y Despuntadoras'));
                        value.push(Math.log10(Math.abs(energeticValueToRefinerasydespuntadoras) + 1));
                        linkColors.push(styleManager.hexToRgba(linkColor, 0.5));
                        linkCustomdata.push(popupManager.generateLinkPopup(
                            energeticName, energeticValueToRefinerasydespuntadoras, energeticName, 'Refiner√≠as y Despuntadoras', linkColor, year,
                            { flowType: 'primary_demand' }
                        ));
                    }
                });
            }

            // Enlaces de energ√©ticos primarios a Centrales El√©ctricas
            if (centraleselectricasNodeData && ofertaInternaBrutaFullData && ofertaInternaBrutaFullData['Nodos Hijo']) {
                const primaryEnergeticsInOIB = ofertaInternaBrutaFullData['Nodos Hijo'].filter(child => child.tipo === 'Energ√≠a Primaria');

                primaryEnergeticsInOIB.forEach(energetic => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticValueToCentraleselectricas = dataManager.getEnergeticValue('Centrales El√©ctricas', energeticName, year);
                    console.log(`[DEBUG - Flujo Centrales El√©ctricas] ${energeticName}: ${energeticValueToCentraleselectricas} `);
                    if (energeticValueToCentraleselectricas !== null && Math.abs(energeticValueToCentraleselectricas) > 0) {
                        const linkColor = styleManager.getEnergyColor(energeticName) || energetic.color;
                        console.log(`[DEBUG - Enlace Centrales El√©ctricas]Energ√©tico: ${energeticName}, Color de enlace: ${linkColor} `);
                        source.push(energeticNodesMap.get(energeticName));
                        target.push(nodeMap.get('Centrales El√©ctricas'));
                        value.push(Math.log10(Math.abs(energeticValueToCentraleselectricas) + 1));
                        linkColors.push(styleManager.hexToRgba(linkColor, 0.5));
                        linkCustomdata.push(popupManager.generateLinkPopup(
                            energeticName, energeticValueToCentraleselectricas, energeticName, 'Centrales El√©ctricas', linkColor, year,
                            { flowType: 'primary_demand' }
                        ));
                    }
                });
            }
            //OJO

            // Enlaces desde Coquizadoras y Hornos a Centrales El√©ctricas (solo secundarios que realmente existen en Coquizadoras)
            if (coquizadorasyhornosNodeData && centraleselectricasNodeData) {
                // Obtenemos los hijos secundarios que realmente existen en Coquizadoras
                const secundarios = (coquizadorasyhornosNodeData['Nodos Hijo'] || [])
                    .filter(energetic => {
                        // Verificamos si este energ√©tico tiene un valor en Coquizadoras
                        const valorEnCoquizadoras = dataManager.getEnergeticValue(
                            'Coquizadoras y Hornos',
                            energetic['Nodo Hijo'],
                            year
                        );
                        return energetic.tipo === 'Energ√≠a Secundaria' &&
                            valorEnCoquizadoras !== null &&
                            Math.abs(valorEnCoquizadoras) > 0;
                    });

                // Para cada energ√©tico secundario que existe en Coquizadoras, creamos el enlace
                secundarios.forEach(energetic => {
                    const energeticName = energetic['Nodo Hijo'];
                    // Obtenemos el valor directamente de Coquizadoras
                    const energeticValue = dataManager.getEnergeticValue(
                        'Coquizadoras y Hornos',
                        energeticName,
                        year
                    );

                    const linkColor = styleManager.getEnergyColor(energeticName) || '#999999';

                    source.push(nodeMap.get('Coquizadoras y Hornos'));
                    target.push(nodeMap.get('Centrales El√©ctricas'));
                    value.push(Math.log10(Math.abs(energeticValue) + 1));
                    linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                    linkCustomdata.push(popupManager.generateLinkPopup(
                        energeticName,
                        energeticValue,
                        'Coquizadoras y Hornos',
                        'Centrales El√©ctricas',
                        linkColor,
                        year,
                        { flowType: 'secondary_supply' }
                    ));
                });
            }

            // Enlaces desde Refiner√≠as y Despuntadoras a Centrales El√©ctricas
            if (refinerasydespuntadorasNodeData && centraleselectricasNodeData) {
                // Obtenemos los hijos secundarios que realmente existen en Refiner√≠as
                const secundarios = (refinerasydespuntadorasNodeData['Nodos Hijo'] || [])
                    .filter(energetic => {
                        const valorEnRefinerias = dataManager.getEnergeticValue(
                            'Refiner√≠as y Despuntadoras',
                            energetic['Nodo Hijo'],
                            year
                        );
                        return energetic.tipo === 'Energ√≠a Secundaria' &&
                            valorEnRefinerias !== null &&
                            Math.abs(valorEnRefinerias) > 0;
                    });

                // Para cada energ√©tico secundario que existe en Refiner√≠as, creamos el enlace
                secundarios.forEach(energetic => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticValue = dataManager.getEnergeticValue(
                        'Refiner√≠as y Despuntadoras',
                        energeticName,
                        year
                    );

                    const linkColor = styleManager.getEnergyColor(energeticName) || '#999999';

                    source.push(nodeMap.get('Refiner√≠as y Despuntadoras'));
                    target.push(nodeMap.get('Centrales El√©ctricas'));
                    value.push(Math.log10(Math.abs(energeticValue) + 1));
                    linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                    linkCustomdata.push(popupManager.generateLinkPopup(
                        energeticName,
                        energeticValue,
                        'Refiner√≠as y Despuntadoras',
                        'Centrales El√©ctricas',
                        linkColor,
                        year,
                        { flowType: 'secondary_supply' }
                    ));
                });
            }

            // Enlaces desde Plantas de Gas y Fraccionadoras a Centrales El√©ctricas
            if (plantasdegasyfraccionadorasNodeData && centraleselectricasNodeData) {
                // Obtenemos los hijos secundarios que realmente existen en Plantas de Gas
                const secundarios = (plantasdegasyfraccionadorasNodeData['Nodos Hijo'] || [])
                    .filter(energetic => {
                        const valorEnPlantas = dataManager.getEnergeticValue(
                            'Plantas de Gas y Fraccionadoras',
                            energetic['Nodo Hijo'],
                            year
                        );
                        return energetic.tipo === 'Energ√≠a Secundaria' &&
                            valorEnPlantas !== null &&
                            Math.abs(valorEnPlantas) > 0;
                    });

                // Para cada energ√©tico secundario que existe en Plantas de Gas, creamos el enlace
                secundarios.forEach(energetic => {
                    const energeticName = energetic['Nodo Hijo'];
                    const energeticValue = dataManager.getEnergeticValue(
                        'Plantas de Gas y Fraccionadoras',
                        energeticName,
                        year
                    );

                    const linkColor = styleManager.getEnergyColor(energeticName) || '#999999';

                    source.push(nodeMap.get('Plantas de Gas y Fraccionadoras'));
                    target.push(nodeMap.get('Centrales El√©ctricas'));
                    value.push(Math.log10(Math.abs(energeticValue) + 1));
                    linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                    linkCustomdata.push(popupManager.generateLinkPopup(
                        energeticName,
                        energeticValue,
                        'Plantas de Gas y Fraccionadoras',
                        'Centrales El√©ctricas',
                        linkColor,
                        year,
                        { flowType: 'secondary_supply' }
                    ));
                });
            }

            // --- Enlaces desde nodos de transformaci√≥n a energ√©ticos secundarios ---
            const transformationNodes = [
                'Coquizadoras y Hornos',
                'Refiner√≠as y Despuntadoras',
                'Plantas de Gas y Fraccionadoras',
                'Centrales El√©ctricas'
            ];
            transformationNodes.forEach(nodeName => {
                const nodeData = dataManager.getNodeData(nodeName);
                console.log(`[DEBUG] Procesando nodo: ${nodeName}`, nodeData);

                if (nodeData && nodeData['Nodos Hijo']) {
                    // Primero mostramos todos los hijos para depuraci√≥n
                    console.log(`[DEBUG] Todos los hijos de ${nodeName}:`,
                        nodeData['Nodos Hijo'].map(c => ({
                            nombre: c['Nodo Hijo'],
                            tipo: c.tipo,
                            isOutput: c.isOutput
                        })));

                    // Luego filtramos
                    // Modificar la secci√≥n de filtrado de salidas secundarias
                    const outputSecondaries = nodeData['Nodos Hijo']
                        .filter(child => {
                            // Verificar si es un energ√©tico secundario
                            const isSecondary = child.tipo === 'Energ√≠a Secundaria';

                            // Verificar si tiene valor para el a√±o actual
                            const hasValue = child[year] !== undefined && child[year] !== null && child[year] > 0;

                            console.log(`[DEBUG] ${nodeName} - ${child['Nodo Hijo']}: `,
                                `tipo=${child.tipo}, valor=${child[year]}, ` +
                                `esSecundario=${isSecondary}, tieneValor=${hasValue}`);

                            return isSecondary && hasValue;
                        });

                    console.log(`[DEBUG] ${nodeName} - Salidas secundarias con valor:`,
                        outputSecondaries.map(e => `${e['Nodo Hijo']} (${e[year]})`));

                    outputSecondaries.forEach(energetic => {
                        const energeticName = energetic['Nodo Hijo'];
                        console.log(`[DEBUG] Procesando enlace para ${nodeName} -> ${energeticName} `);

                        const targetNodeIndex = secondaryEnergeticNodesMap.get(energeticName);
                        if (targetNodeIndex === undefined) {
                            console.warn(`[WARN] No se encontr√≥ el nodo destino para ${energeticName} en el mapa de nodos secundarios`);
                            console.log('[DEBUG] Mapa actual de nodos secundarios:', [...secondaryEnergeticNodesMap.keys()]);
                            return;
                        }

                        const sourceNodeIndex = nodeMap.get(nodeName);
                        if (sourceNodeIndex === undefined) {
                            console.warn(`[WARN] No se encontr√≥ el √≠ndice para el nodo fuente: ${nodeName} `);
                            return;
                        }

                        // Cambio importante: Usar directamente el valor del a√±o del objeto energetic
                        const energeticValue = parseFloat(energetic[year]) || 0;
                        console.log(`[DEBUG] Valor obtenido para ${nodeName} -> ${energeticName}: `, energeticValue);

                        if (energeticValue > 0) {  // Ya no necesitamos Math.abs ya que verificamos > 0
                            const linkColor = styleManager.getEnergyColor(energeticName) || '#999999';

                            source.push(sourceNodeIndex);
                            target.push(targetNodeIndex);
                            value.push(Math.log10(energeticValue + 1));
                            linkColors.push(styleManager.hexToRgba(linkColor, 0.5));

                            console.log(`[DEBUG] Creando enlace: ${nodeName} (${sourceNodeIndex}) -> ${energeticName} (${targetNodeIndex}) = ${energeticValue}`);

                            linkCustomdata.push(popupManager.generateLinkPopup(
                                energeticName,
                                energeticValue,
                                nodeName,
                                energeticName,
                                linkColor,
                                year,
                                { flowType: 'secondary_output' }
                            ));
                        } else {
                            console.log(`[DEBUG] Valor no v√°lido o cero para ${nodeName} -> ${energeticName}: `, energeticValue);
                        }
                    });
                } else {
                    console.warn(`[WARN] No se encontraron datos o hijos para el nodo: ${nodeName} `);
                }
            });


            const data = {
                type: "sankey",
                orientation: "h",
                node: {
                    pad: 100,
                    thickness: 10,
                    line: { color: "black", width: 0.5 },
                    label: labels,
                    color: nodeColors,
                    hovertemplate: '%{customdata}<extra></extra>',
                    customdata: nodeCustomdata, // Usar el nuevo array nodeCustomdata
                    x: nodeX,
                    y: nodeY
                },
                link: {
                    source: source,
                    target: target,
                    value: value,
                    color: linkColors,
                    customdata: linkCustomdata,
                    hovertemplate: '%{customdata}<extra></extra>'
                }
            };

            const layout = {
                title: `Balance Nacional de Energ√≠a - ${year} (Valores en PJ)`,
                font: { size: 12 },
                margin: { l: 10, r: 10, t: 50, b: 10 },
                autosize: true
            };
            const config = {
                displaylogo: false,
                responsive: true,
                toImageButtonOptions: {
                    format: 'png',
                    filename: `sankey_energia_primaria_${year}`,
                    setBackground: 'transparent',
                    width: 1920,
                    height: 1080,
                    scale: 1
                }
            };

            Plotly.newPlot(sankeyDiv, [data], layout, config).then(() => {
                // Renderizar etiquetas de columnas despu√©s de que el diagrama est√© listo
                if (columnLabelsManager && columnLabelsManager.isEnabled()) {
                    // Usar setTimeout para asegurar que el diagrama est√© completamente renderizado
                    setTimeout(() => {
                        columnLabelsManager.renderLabels(sankeyDiv);
                    }, 100);
                }
            }).catch(error => {
                console.error('Error al renderizar el diagrama de Sankey:', error);
            });
        }
    </script>
</body>

</html>